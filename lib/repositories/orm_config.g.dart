// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'orm_config.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:User.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// User TABLE
class TableUser extends SqfEntityTableBase {
  TableUser() {
    // declare properties of EntityTable
    tableName = 'users';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('isActive', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('isCanceled', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('createdBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('lastModifiedDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('modifyBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDateInLocal', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('username', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('mobile', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('nationalAddress', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('nationalID', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('maxDebtLimit', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('numTermBills', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('prevTermBalance', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('debtorOrCreditor', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('knownAs', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('photoUrl', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUser();
  }
}

// Product TABLE
class TableProduct extends SqfEntityTableBase {
  TableProduct() {
    // declare properties of EntityTable
    tableName = 'products';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('isActive', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('isCanceled', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('createdBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('lastModifiedDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('modifyBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDateInLocal', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('productName', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('productNum', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('serialNumber', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('description', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('imageUrl', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('catId', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('vat', DbType.real,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('canBuy', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('canSale', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProduct();
  }
}

// Category TABLE
class TableCategory extends SqfEntityTableBase {
  TableCategory() {
    // declare properties of EntityTable
    tableName = 'categories';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('isActive', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('isCanceled', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('createdBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('lastModifiedDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('modifyBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDateInLocal', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('categoryTitle', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('description', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('underMainId', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('isMain', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('isSub', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCategory();
  }
}

// UnitsProduct TABLE
class TableUnitsProduct extends SqfEntityTableBase {
  TableUnitsProduct() {
    // declare properties of EntityTable
    tableName = 'unitsProduct';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('isActive', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('isCanceled', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('createdBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('lastModifiedDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('modifyBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDateInLocal', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('sellPrice', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('buyPrice', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('barcode', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('quantity', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('description', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('productId', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('unitId', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUnitsProduct();
  }
}

// Unit TABLE
class TableUnit extends SqfEntityTableBase {
  TableUnit() {
    // declare properties of EntityTable
    tableName = 'units';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('isActive', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('isCanceled', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('createdBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('lastModifiedDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('modifyBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDateInLocal', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('unitTitle', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('size', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('needBalance', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUnit();
  }
}

// BuyInvoice TABLE
class TableBuyInvoice extends SqfEntityTableBase {
  TableBuyInvoice() {
    // declare properties of EntityTable
    tableName = 'buyInvoices';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('isActive', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('isCanceled', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('createdBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('lastModifiedDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('modifyBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDateInLocal', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('discountType', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('vatPercent', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('countItem', DbType.integer,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('clientId', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('clientName', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('totalNetBill', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('totalBeforeDiscount', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('discountAmount', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('totalAfterDiscount', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('vatAmount', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('totalAfterVAT', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('totalBillFinal', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('payedAmount', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('remainingAmount', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('notPayedAmount', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBuyInvoice();
  }
}

// InvoiceDetail TABLE
class TableInvoiceDetail extends SqfEntityTableBase {
  TableInvoiceDetail() {
    // declare properties of EntityTable
    tableName = 'invoiceDetails';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('isActive', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('isCanceled', DbType.bool,
          defaultValue: false,
          isUnique: false,
          isNotNull: false,
          isIndex: false),
      SqfEntityFieldBase('createdBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('lastModifiedDate', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('modifyBy', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('createdDateInLocal', DbType.datetime,
          isUnique: false,
          isNotNull: false,
          isIndex: false,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('invoiceId', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('unitProductId', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
      SqfEntityFieldBase('quantity', DbType.text,
          isUnique: false, isNotNull: false, isIndex: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInvoiceDetail();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class MyAppDatabaseModel extends SqfEntityModelProvider {
  MyAppDatabaseModel() {
    databaseName = myDbModel.databaseName;
    password = myDbModel.password;
    dbVersion = myDbModel.dbVersion;
    preSaveAction = myDbModel.preSaveAction;
    logFunction = myDbModel.logFunction;
    databaseTables = [
      TableUser.getInstance,
      TableProduct.getInstance,
      TableCategory.getInstance,
      TableUnitsProduct.getInstance,
      TableUnit.getInstance,
      TableBuyInvoice.getInstance,
      TableInvoiceDetail.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = myDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region User
class User extends TableBase {
  User(
      {this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.username,
      this.mobile,
      this.nationalAddress,
      this.nationalID,
      this.maxDebtLimit,
      this.numTermBills,
      this.prevTermBalance,
      this.debtorOrCreditor,
      this.knownAs,
      this.photoUrl}) {
    _setDefaultValues();
  }
  User.withFields(
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.username,
      this.mobile,
      this.nationalAddress,
      this.nationalID,
      this.maxDebtLimit,
      this.numTermBills,
      this.prevTermBalance,
      this.debtorOrCreditor,
      this.knownAs,
      this.photoUrl) {
    _setDefaultValues();
  }
  User.withId(
      this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.username,
      this.mobile,
      this.nationalAddress,
      this.nationalID,
      this.maxDebtLimit,
      this.numTermBills,
      this.prevTermBalance,
      this.debtorOrCreditor,
      this.knownAs,
      this.photoUrl) {
    _setDefaultValues();
  }
  // fromMap v2.0
  User.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['isCanceled'] != null) {
      isCanceled = o['isCanceled'].toString() == '1' ||
          o['isCanceled'].toString() == 'true';
    }
    if (o['createdBy'] != null) {
      createdBy = o['createdBy'].toString();
    }
    if (o['createdDate'] != null) {
      createdDate = int.tryParse(o['createdDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdDate'].toString())!)
          : DateTime.tryParse(o['createdDate'].toString());
    }
    if (o['lastModifiedDate'] != null) {
      lastModifiedDate = int.tryParse(o['lastModifiedDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['lastModifiedDate'].toString())!)
          : DateTime.tryParse(o['lastModifiedDate'].toString());
    }
    if (o['modifyBy'] != null) {
      modifyBy = o['modifyBy'].toString();
    }
    if (o['createdDateInLocal'] != null) {
      createdDateInLocal =
          int.tryParse(o['createdDateInLocal'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['createdDateInLocal'].toString())!)
              : DateTime.tryParse(o['createdDateInLocal'].toString());
    }
    if (o['username'] != null) {
      username = o['username'].toString();
    }
    if (o['mobile'] != null) {
      mobile = o['mobile'].toString();
    }
    if (o['nationalAddress'] != null) {
      nationalAddress = o['nationalAddress'].toString();
    }
    if (o['nationalID'] != null) {
      nationalID = o['nationalID'].toString();
    }
    if (o['maxDebtLimit'] != null) {
      maxDebtLimit = o['maxDebtLimit'].toString();
    }
    if (o['numTermBills'] != null) {
      numTermBills = o['numTermBills'].toString();
    }
    if (o['prevTermBalance'] != null) {
      prevTermBalance = o['prevTermBalance'].toString();
    }
    if (o['debtorOrCreditor'] != null) {
      debtorOrCreditor = int.tryParse(o['debtorOrCreditor'].toString());
    }
    if (o['knownAs'] != null) {
      knownAs = o['knownAs'].toString();
    }
    if (o['photoUrl'] != null) {
      photoUrl = o['photoUrl'].toString();
    }
  }
  // FIELDS (User)
  int? id;
  bool? isActive;
  bool? isCanceled;
  String? createdBy;
  DateTime? createdDate;
  DateTime? lastModifiedDate;
  String? modifyBy;
  DateTime? createdDateInLocal;
  String? username;
  String? mobile;
  String? nationalAddress;
  String? nationalID;
  String? maxDebtLimit;
  String? numTermBills;
  String? prevTermBalance;
  int? debtorOrCreditor;
  String? knownAs;
  String? photoUrl;

  BoolResult? saveResult;
  // end FIELDS (User)

  static const bool _softDeleteActivated = false;
  UserManager? __mnUser;

  UserManager get _mnUser {
    return __mnUser = __mnUser ?? UserManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (username != null) {
      map['username'] = username;
    }

    if (mobile != null) {
      map['mobile'] = mobile;
    }

    if (nationalAddress != null) {
      map['nationalAddress'] = nationalAddress;
    }

    if (nationalID != null) {
      map['nationalID'] = nationalID;
    }

    if (maxDebtLimit != null) {
      map['maxDebtLimit'] = maxDebtLimit;
    }

    if (numTermBills != null) {
      map['numTermBills'] = numTermBills;
    }

    if (prevTermBalance != null) {
      map['prevTermBalance'] = prevTermBalance;
    }

    if (debtorOrCreditor != null) {
      map['debtorOrCreditor'] = debtorOrCreditor;
    }

    if (knownAs != null) {
      map['knownAs'] = knownAs;
    }

    if (photoUrl != null) {
      map['photoUrl'] = photoUrl;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (username != null) {
      map['username'] = username;
    }

    if (mobile != null) {
      map['mobile'] = mobile;
    }

    if (nationalAddress != null) {
      map['nationalAddress'] = nationalAddress;
    }

    if (nationalID != null) {
      map['nationalID'] = nationalID;
    }

    if (maxDebtLimit != null) {
      map['maxDebtLimit'] = maxDebtLimit;
    }

    if (numTermBills != null) {
      map['numTermBills'] = numTermBills;
    }

    if (prevTermBalance != null) {
      map['prevTermBalance'] = prevTermBalance;
    }

    if (debtorOrCreditor != null) {
      map['debtorOrCreditor'] = debtorOrCreditor;
    }

    if (knownAs != null) {
      map['knownAs'] = knownAs;
    }

    if (photoUrl != null) {
      map['photoUrl'] = photoUrl;
    }

    return map;
  }

  /// This method returns Json String [User]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [User]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      username,
      mobile,
      nationalAddress,
      nationalID,
      maxDebtLimit,
      numTermBills,
      prevTermBalance,
      debtorOrCreditor,
      knownAs,
      photoUrl
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      username,
      mobile,
      nationalAddress,
      nationalID,
      maxDebtLimit,
      numTermBills,
      prevTermBalance,
      debtorOrCreditor,
      knownAs,
      photoUrl
    ];
  }

  static Future<List<User>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<User>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <User>[];
    try {
      objList = list
          .map((user) => User.fromMap(user as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR User.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<User>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<User> objList = <User>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = User.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns User by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns User if exist, otherwise returns null
  Future<User?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    User? obj;
    final data = await _mnUser.getById([id]);
    if (data.length != 0) {
      obj = User.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (User) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUser.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUser.update(this);
    }

    return id;
  }

  /// Saves the (User) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUser.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUser.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs User. Returns a new Primary Key value of User

  /// <returns>Returns a new Primary Key value of User
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<User> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<User> users) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyAppDatabaseModel().batchStart();
    for (final obj in users) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyAppDatabaseModel().batchCommit();
      for (int i = 0; i < users.length; i++) {
        if (users[i].id == null) {
          users[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnUser.rawInsert(
          'INSERT OR REPLACE INTO users (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, username, mobile, nationalAddress, nationalID, maxDebtLimit, numTermBills, prevTermBalance, debtorOrCreditor, knownAs, photoUrl)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            isActive,
            isCanceled,
            createdBy,
            createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
            lastModifiedDate != null
                ? lastModifiedDate!.millisecondsSinceEpoch
                : null,
            modifyBy,
            createdDateInLocal != null
                ? createdDateInLocal!.millisecondsSinceEpoch
                : null,
            username,
            mobile,
            nationalAddress,
            nationalID,
            maxDebtLimit,
            numTermBills,
            prevTermBalance,
            debtorOrCreditor,
            knownAs,
            photoUrl
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'User id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'User id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'User Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<User>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<User> users) async {
    final results = await _mnUser.rawInsertAll(
        'INSERT OR REPLACE INTO users (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, username, mobile, nationalAddress, nationalID, maxDebtLimit, numTermBills, prevTermBalance, debtorOrCreditor, knownAs, photoUrl)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        users);
    return results;
  }

  /// Deletes User

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete User invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUser
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUser.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  UserFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  UserFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UserFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? false;
    isCanceled = isCanceled ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion user

// region UserField
class UserField extends SearchCriteria {
  UserField(this.userFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  UserFilterBuilder userFB;

  UserField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  UserFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    userFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, userFB.parameters, param, SqlSyntax.EQuals,
            userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param, SqlSyntax.NotEQuals,
            userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    userFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, userFB.parameters, param, SqlSyntax.EQualsOrNull,
            userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder isNull() {
    userFB._addedBlocks = setCriteria(
        0,
        userFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      userFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          userFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          userFB._addedBlocks);
      _waitingNot = '';
      userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
          userFB._addedBlocks.retVal;
    }
    return userFB;
  }

  UserFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      userFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          userFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          userFB._addedBlocks);
      _waitingNot = '';
      userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
          userFB._addedBlocks.retVal;
      userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
          userFB._addedBlocks.retVal;
    }
    return userFB;
  }

  UserFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      userFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          userFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          userFB._addedBlocks);
      _waitingNot = '';
      userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
          userFB._addedBlocks.retVal;
    }
    return userFB;
  }

  UserFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      userFB._addedBlocks = setCriteria(
          pFirst,
          userFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          userFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        userFB._addedBlocks = setCriteria(pFirst, userFB.parameters, param,
            SqlSyntax.LessThan, userFB._addedBlocks);
      } else {
        userFB._addedBlocks = setCriteria(pFirst, userFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, userFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        userFB._addedBlocks = setCriteria(pLast, userFB.parameters, param,
            SqlSyntax.GreaterThan, userFB._addedBlocks);
      } else {
        userFB._addedBlocks = setCriteria(pLast, userFB.parameters, param,
            SqlSyntax.LessThanOrEquals, userFB._addedBlocks);
      }
    }
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    userFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, userFB.parameters, param, SqlSyntax.GreaterThan,
            userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param,
            SqlSyntax.LessThanOrEquals, userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    userFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, userFB.parameters, param, SqlSyntax.LessThan,
            userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    userFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, userFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param, SqlSyntax.LessThan,
            userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    userFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, userFB.parameters, param,
            SqlSyntax.LessThanOrEquals, userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param, SqlSyntax.GreaterThan,
            userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }

  UserFilterBuilder inValues(dynamic pValue) {
    userFB._addedBlocks = setCriteria(
        pValue,
        userFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        userFB._addedBlocks);
    _waitingNot = '';
    userFB._addedBlocks.needEndBlock![userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
}
// endregion UserField

// region UserFilterBuilder
class UserFilterBuilder extends SearchCriteria {
  UserFilterBuilder(User obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  User? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  UserFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  UserFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  UserFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  UserFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  UserFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  UserFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  UserFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UserFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UserFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UserFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UserFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  UserField setField(UserField? field, String colName, DbType dbtype) {
    return UserField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  UserField? _id;
  UserField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  UserField? _isActive;
  UserField get isActive {
    return _isActive = setField(_isActive, 'isActive', DbType.bool);
  }

  UserField? _isCanceled;
  UserField get isCanceled {
    return _isCanceled = setField(_isCanceled, 'isCanceled', DbType.bool);
  }

  UserField? _createdBy;
  UserField get createdBy {
    return _createdBy = setField(_createdBy, 'createdBy', DbType.text);
  }

  UserField? _createdDate;
  UserField get createdDate {
    return _createdDate =
        setField(_createdDate, 'createdDate', DbType.datetime);
  }

  UserField? _lastModifiedDate;
  UserField get lastModifiedDate {
    return _lastModifiedDate =
        setField(_lastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  UserField? _modifyBy;
  UserField get modifyBy {
    return _modifyBy = setField(_modifyBy, 'modifyBy', DbType.text);
  }

  UserField? _createdDateInLocal;
  UserField get createdDateInLocal {
    return _createdDateInLocal =
        setField(_createdDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  UserField? _username;
  UserField get username {
    return _username = setField(_username, 'username', DbType.text);
  }

  UserField? _mobile;
  UserField get mobile {
    return _mobile = setField(_mobile, 'mobile', DbType.text);
  }

  UserField? _nationalAddress;
  UserField get nationalAddress {
    return _nationalAddress =
        setField(_nationalAddress, 'nationalAddress', DbType.text);
  }

  UserField? _nationalID;
  UserField get nationalID {
    return _nationalID = setField(_nationalID, 'nationalID', DbType.text);
  }

  UserField? _maxDebtLimit;
  UserField get maxDebtLimit {
    return _maxDebtLimit = setField(_maxDebtLimit, 'maxDebtLimit', DbType.text);
  }

  UserField? _numTermBills;
  UserField get numTermBills {
    return _numTermBills = setField(_numTermBills, 'numTermBills', DbType.text);
  }

  UserField? _prevTermBalance;
  UserField get prevTermBalance {
    return _prevTermBalance =
        setField(_prevTermBalance, 'prevTermBalance', DbType.text);
  }

  UserField? _debtorOrCreditor;
  UserField get debtorOrCreditor {
    return _debtorOrCreditor =
        setField(_debtorOrCreditor, 'debtorOrCreditor', DbType.integer);
  }

  UserField? _knownAs;
  UserField get knownAs {
    return _knownAs = setField(_knownAs, 'knownAs', DbType.text);
  }

  UserField? _photoUrl;
  UserField get photoUrl {
    return _photoUrl = setField(_photoUrl, 'photoUrl', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (User._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<User> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (User._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnUser.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnUser.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from users ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnUser.updateBatch(qparams, values);
  }

  /// This method always returns User Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<User>
  Future<User?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnUser.toList(qparams);
    final data = await objFuture;
    User? obj;
    if (data.isNotEmpty) {
      obj = User.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [User]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? userCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final usersFuture = await _obj!._mnUser.toList(qparams);
    final int count = usersFuture[0]['CNT'] as int;
    if (userCount != null) {
      userCount(count);
    }
    return count;
  }

  /// This method returns List<User> [User]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<User>
  Future<List<User>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<User> usersData = await User.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return usersData;
  }

  /// This method returns Json String [User]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [User]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [User]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnUser.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [User]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM users WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnUser.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [User]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnUser.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await User.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnUser.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UserFilterBuilder

// region UserFields
class UserFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fIsCanceled;
  static TableField get isCanceled {
    return _fIsCanceled = _fIsCanceled ??
        SqlSyntax.setField(_fIsCanceled, 'isCanceled', DbType.bool);
  }

  static TableField? _fCreatedBy;
  static TableField get createdBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'createdBy', DbType.text);
  }

  static TableField? _fCreatedDate;
  static TableField get createdDate {
    return _fCreatedDate = _fCreatedDate ??
        SqlSyntax.setField(_fCreatedDate, 'createdDate', DbType.datetime);
  }

  static TableField? _fLastModifiedDate;
  static TableField get lastModifiedDate {
    return _fLastModifiedDate = _fLastModifiedDate ??
        SqlSyntax.setField(
            _fLastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  static TableField? _fModifyBy;
  static TableField get modifyBy {
    return _fModifyBy =
        _fModifyBy ?? SqlSyntax.setField(_fModifyBy, 'modifyBy', DbType.text);
  }

  static TableField? _fCreatedDateInLocal;
  static TableField get createdDateInLocal {
    return _fCreatedDateInLocal = _fCreatedDateInLocal ??
        SqlSyntax.setField(
            _fCreatedDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  static TableField? _fUsername;
  static TableField get username {
    return _fUsername =
        _fUsername ?? SqlSyntax.setField(_fUsername, 'username', DbType.text);
  }

  static TableField? _fMobile;
  static TableField get mobile {
    return _fMobile =
        _fMobile ?? SqlSyntax.setField(_fMobile, 'mobile', DbType.text);
  }

  static TableField? _fNationalAddress;
  static TableField get nationalAddress {
    return _fNationalAddress = _fNationalAddress ??
        SqlSyntax.setField(_fNationalAddress, 'nationalAddress', DbType.text);
  }

  static TableField? _fNationalID;
  static TableField get nationalID {
    return _fNationalID = _fNationalID ??
        SqlSyntax.setField(_fNationalID, 'nationalID', DbType.text);
  }

  static TableField? _fMaxDebtLimit;
  static TableField get maxDebtLimit {
    return _fMaxDebtLimit = _fMaxDebtLimit ??
        SqlSyntax.setField(_fMaxDebtLimit, 'maxDebtLimit', DbType.text);
  }

  static TableField? _fNumTermBills;
  static TableField get numTermBills {
    return _fNumTermBills = _fNumTermBills ??
        SqlSyntax.setField(_fNumTermBills, 'numTermBills', DbType.text);
  }

  static TableField? _fPrevTermBalance;
  static TableField get prevTermBalance {
    return _fPrevTermBalance = _fPrevTermBalance ??
        SqlSyntax.setField(_fPrevTermBalance, 'prevTermBalance', DbType.text);
  }

  static TableField? _fDebtorOrCreditor;
  static TableField get debtorOrCreditor {
    return _fDebtorOrCreditor = _fDebtorOrCreditor ??
        SqlSyntax.setField(
            _fDebtorOrCreditor, 'debtorOrCreditor', DbType.integer);
  }

  static TableField? _fKnownAs;
  static TableField get knownAs {
    return _fKnownAs =
        _fKnownAs ?? SqlSyntax.setField(_fKnownAs, 'knownAs', DbType.text);
  }

  static TableField? _fPhotoUrl;
  static TableField get photoUrl {
    return _fPhotoUrl =
        _fPhotoUrl ?? SqlSyntax.setField(_fPhotoUrl, 'photoUrl', DbType.text);
  }
}
// endregion UserFields

//region UserManager
class UserManager extends SqfEntityProvider {
  UserManager()
      : super(MyAppDatabaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'users';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion UserManager
// region Product
class Product extends TableBase {
  Product(
      {this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.productName,
      this.productNum,
      this.serialNumber,
      this.description,
      this.imageUrl,
      this.catId,
      this.vat,
      this.canBuy,
      this.canSale}) {
    _setDefaultValues();
  }
  Product.withFields(
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.productName,
      this.productNum,
      this.serialNumber,
      this.description,
      this.imageUrl,
      this.catId,
      this.vat,
      this.canBuy,
      this.canSale) {
    _setDefaultValues();
  }
  Product.withId(
      this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.productName,
      this.productNum,
      this.serialNumber,
      this.description,
      this.imageUrl,
      this.catId,
      this.vat,
      this.canBuy,
      this.canSale) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Product.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['isCanceled'] != null) {
      isCanceled = o['isCanceled'].toString() == '1' ||
          o['isCanceled'].toString() == 'true';
    }
    if (o['createdBy'] != null) {
      createdBy = o['createdBy'].toString();
    }
    if (o['createdDate'] != null) {
      createdDate = int.tryParse(o['createdDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdDate'].toString())!)
          : DateTime.tryParse(o['createdDate'].toString());
    }
    if (o['lastModifiedDate'] != null) {
      lastModifiedDate = int.tryParse(o['lastModifiedDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['lastModifiedDate'].toString())!)
          : DateTime.tryParse(o['lastModifiedDate'].toString());
    }
    if (o['modifyBy'] != null) {
      modifyBy = o['modifyBy'].toString();
    }
    if (o['createdDateInLocal'] != null) {
      createdDateInLocal =
          int.tryParse(o['createdDateInLocal'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['createdDateInLocal'].toString())!)
              : DateTime.tryParse(o['createdDateInLocal'].toString());
    }
    if (o['productName'] != null) {
      productName = o['productName'].toString();
    }
    if (o['productNum'] != null) {
      productNum = int.tryParse(o['productNum'].toString());
    }
    if (o['serialNumber'] != null) {
      serialNumber = o['serialNumber'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['imageUrl'] != null) {
      imageUrl = o['imageUrl'].toString();
    }
    if (o['catId'] != null) {
      catId = o['catId'].toString();
    }
    if (o['vat'] != null) {
      vat = double.tryParse(o['vat'].toString());
    }
    if (o['canBuy'] != null) {
      canBuy = int.tryParse(o['canBuy'].toString());
    }
    if (o['canSale'] != null) {
      canSale = int.tryParse(o['canSale'].toString());
    }
  }
  // FIELDS (Product)
  int? id;
  bool? isActive;
  bool? isCanceled;
  String? createdBy;
  DateTime? createdDate;
  DateTime? lastModifiedDate;
  String? modifyBy;
  DateTime? createdDateInLocal;
  String? productName;
  int? productNum;
  String? serialNumber;
  String? description;
  String? imageUrl;
  String? catId;
  double? vat;
  int? canBuy;
  int? canSale;

  BoolResult? saveResult;
  // end FIELDS (Product)

  static const bool _softDeleteActivated = false;
  ProductManager? __mnProduct;

  ProductManager get _mnProduct {
    return __mnProduct = __mnProduct ?? ProductManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (productName != null) {
      map['productName'] = productName;
    }

    if (productNum != null) {
      map['productNum'] = productNum;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (imageUrl != null) {
      map['imageUrl'] = imageUrl;
    }

    if (catId != null) {
      map['catId'] = catId;
    }

    if (vat != null) {
      map['vat'] = vat;
    }

    if (canBuy != null) {
      map['canBuy'] = canBuy;
    }

    if (canSale != null) {
      map['canSale'] = canSale;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (productName != null) {
      map['productName'] = productName;
    }

    if (productNum != null) {
      map['productNum'] = productNum;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (imageUrl != null) {
      map['imageUrl'] = imageUrl;
    }

    if (catId != null) {
      map['catId'] = catId;
    }

    if (vat != null) {
      map['vat'] = vat;
    }

    if (canBuy != null) {
      map['canBuy'] = canBuy;
    }

    if (canSale != null) {
      map['canSale'] = canSale;
    }

    return map;
  }

  /// This method returns Json String [Product]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Product]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      productName,
      productNum,
      serialNumber,
      description,
      imageUrl,
      catId,
      vat,
      canBuy,
      canSale
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      productName,
      productNum,
      serialNumber,
      description,
      imageUrl,
      catId,
      vat,
      canBuy,
      canSale
    ];
  }

  static Future<List<Product>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Product.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Product>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Product>[];
    try {
      objList = list
          .map((product) => Product.fromMap(product as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Product.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Product>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Product> objList = <Product>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Product.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Product by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Product if exist, otherwise returns null
  Future<Product?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Product? obj;
    final data = await _mnProduct.getById([id]);
    if (data.length != 0) {
      obj = Product.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Product) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProduct.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnProduct.update(this);
    }

    return id;
  }

  /// Saves the (Product) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProduct.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnProduct.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Product. Returns a new Primary Key value of Product

  /// <returns>Returns a new Primary Key value of Product
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Product> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Product> products) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyAppDatabaseModel().batchStart();
    for (final obj in products) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyAppDatabaseModel().batchCommit();
      for (int i = 0; i < products.length; i++) {
        if (products[i].id == null) {
          products[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnProduct.rawInsert(
          'INSERT OR REPLACE INTO products (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, productName, productNum, serialNumber, description, imageUrl, catId, vat, canBuy, canSale)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            isActive,
            isCanceled,
            createdBy,
            createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
            lastModifiedDate != null
                ? lastModifiedDate!.millisecondsSinceEpoch
                : null,
            modifyBy,
            createdDateInLocal != null
                ? createdDateInLocal!.millisecondsSinceEpoch
                : null,
            productName,
            productNum,
            serialNumber,
            description,
            imageUrl,
            catId,
            vat,
            canBuy,
            canSale
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Product id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Product id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Product Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Product>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Product> products) async {
    final results = await _mnProduct.rawInsertAll(
        'INSERT OR REPLACE INTO products (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, productName, productNum, serialNumber, description, imageUrl, catId, vat, canBuy, canSale)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        products);
    return results;
  }

  /// Deletes Product

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Product invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnProduct
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnProduct.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  ProductFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ProductFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? false;
    isCanceled = isCanceled ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion product

// region ProductField
class ProductField extends SearchCriteria {
  ProductField(this.productFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  ProductFilterBuilder productFB;

  ProductField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ProductFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    productFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, productFB.parameters, param, SqlSyntax.EQuals,
            productFB._addedBlocks)
        : setCriteria(pValue, productFB.parameters, param, SqlSyntax.NotEQuals,
            productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    productFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.EQualsOrNull, productFB._addedBlocks)
        : setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder isNull() {
    productFB._addedBlocks = setCriteria(
        0,
        productFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      productFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          productFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          productFB._addedBlocks);
      _waitingNot = '';
      productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
          productFB._addedBlocks.retVal;
    }
    return productFB;
  }

  ProductFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      productFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          productFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          productFB._addedBlocks);
      _waitingNot = '';
      productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
          productFB._addedBlocks.retVal;
      productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
          productFB._addedBlocks.retVal;
    }
    return productFB;
  }

  ProductFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      productFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          productFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          productFB._addedBlocks);
      _waitingNot = '';
      productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
          productFB._addedBlocks.retVal;
    }
    return productFB;
  }

  ProductFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      productFB._addedBlocks = setCriteria(
          pFirst,
          productFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          productFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        productFB._addedBlocks = setCriteria(pFirst, productFB.parameters,
            param, SqlSyntax.LessThan, productFB._addedBlocks);
      } else {
        productFB._addedBlocks = setCriteria(pFirst, productFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, productFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        productFB._addedBlocks = setCriteria(pLast, productFB.parameters, param,
            SqlSyntax.GreaterThan, productFB._addedBlocks);
      } else {
        productFB._addedBlocks = setCriteria(pLast, productFB.parameters, param,
            SqlSyntax.LessThanOrEquals, productFB._addedBlocks);
      }
    }
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    productFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.GreaterThan, productFB._addedBlocks)
        : setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.LessThanOrEquals, productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    productFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, productFB.parameters, param, SqlSyntax.LessThan,
            productFB._addedBlocks)
        : setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    productFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, productFB._addedBlocks)
        : setCriteria(pValue, productFB.parameters, param, SqlSyntax.LessThan,
            productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    productFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.LessThanOrEquals, productFB._addedBlocks)
        : setCriteria(pValue, productFB.parameters, param,
            SqlSyntax.GreaterThan, productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }

  ProductFilterBuilder inValues(dynamic pValue) {
    productFB._addedBlocks = setCriteria(
        pValue,
        productFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        productFB._addedBlocks);
    _waitingNot = '';
    productFB._addedBlocks.needEndBlock![productFB._blockIndex] =
        productFB._addedBlocks.retVal;
    return productFB;
  }
}
// endregion ProductField

// region ProductFilterBuilder
class ProductFilterBuilder extends SearchCriteria {
  ProductFilterBuilder(Product obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Product? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  ProductFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ProductFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ProductFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ProductFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ProductFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ProductFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ProductFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ProductFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ProductFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ProductFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ProductFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ProductField setField(ProductField? field, String colName, DbType dbtype) {
    return ProductField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  ProductField? _id;
  ProductField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  ProductField? _isActive;
  ProductField get isActive {
    return _isActive = setField(_isActive, 'isActive', DbType.bool);
  }

  ProductField? _isCanceled;
  ProductField get isCanceled {
    return _isCanceled = setField(_isCanceled, 'isCanceled', DbType.bool);
  }

  ProductField? _createdBy;
  ProductField get createdBy {
    return _createdBy = setField(_createdBy, 'createdBy', DbType.text);
  }

  ProductField? _createdDate;
  ProductField get createdDate {
    return _createdDate =
        setField(_createdDate, 'createdDate', DbType.datetime);
  }

  ProductField? _lastModifiedDate;
  ProductField get lastModifiedDate {
    return _lastModifiedDate =
        setField(_lastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  ProductField? _modifyBy;
  ProductField get modifyBy {
    return _modifyBy = setField(_modifyBy, 'modifyBy', DbType.text);
  }

  ProductField? _createdDateInLocal;
  ProductField get createdDateInLocal {
    return _createdDateInLocal =
        setField(_createdDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  ProductField? _productName;
  ProductField get productName {
    return _productName = setField(_productName, 'productName', DbType.text);
  }

  ProductField? _productNum;
  ProductField get productNum {
    return _productNum = setField(_productNum, 'productNum', DbType.integer);
  }

  ProductField? _serialNumber;
  ProductField get serialNumber {
    return _serialNumber = setField(_serialNumber, 'serialNumber', DbType.text);
  }

  ProductField? _description;
  ProductField get description {
    return _description = setField(_description, 'description', DbType.text);
  }

  ProductField? _imageUrl;
  ProductField get imageUrl {
    return _imageUrl = setField(_imageUrl, 'imageUrl', DbType.text);
  }

  ProductField? _catId;
  ProductField get catId {
    return _catId = setField(_catId, 'catId', DbType.text);
  }

  ProductField? _vat;
  ProductField get vat {
    return _vat = setField(_vat, 'vat', DbType.real);
  }

  ProductField? _canBuy;
  ProductField get canBuy {
    return _canBuy = setField(_canBuy, 'canBuy', DbType.integer);
  }

  ProductField? _canSale;
  ProductField get canSale {
    return _canSale = setField(_canSale, 'canSale', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Product._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Product> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Product._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnProduct.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnProduct.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from products ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnProduct.updateBatch(qparams, values);
  }

  /// This method always returns Product Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Product>
  Future<Product?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnProduct.toList(qparams);
    final data = await objFuture;
    Product? obj;
    if (data.isNotEmpty) {
      obj = Product.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Product]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? productCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final productsFuture = await _obj!._mnProduct.toList(qparams);
    final int count = productsFuture[0]['CNT'] as int;
    if (productCount != null) {
      productCount(count);
    }
    return count;
  }

  /// This method returns List<Product> [Product]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Product>
  Future<List<Product>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Product> productsData = await Product.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return productsData;
  }

  /// This method returns Json String [Product]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Product]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Product]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnProduct.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Product]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM products WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnProduct.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Product]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnProduct.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Product.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnProduct.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProductFilterBuilder

// region ProductFields
class ProductFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fIsCanceled;
  static TableField get isCanceled {
    return _fIsCanceled = _fIsCanceled ??
        SqlSyntax.setField(_fIsCanceled, 'isCanceled', DbType.bool);
  }

  static TableField? _fCreatedBy;
  static TableField get createdBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'createdBy', DbType.text);
  }

  static TableField? _fCreatedDate;
  static TableField get createdDate {
    return _fCreatedDate = _fCreatedDate ??
        SqlSyntax.setField(_fCreatedDate, 'createdDate', DbType.datetime);
  }

  static TableField? _fLastModifiedDate;
  static TableField get lastModifiedDate {
    return _fLastModifiedDate = _fLastModifiedDate ??
        SqlSyntax.setField(
            _fLastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  static TableField? _fModifyBy;
  static TableField get modifyBy {
    return _fModifyBy =
        _fModifyBy ?? SqlSyntax.setField(_fModifyBy, 'modifyBy', DbType.text);
  }

  static TableField? _fCreatedDateInLocal;
  static TableField get createdDateInLocal {
    return _fCreatedDateInLocal = _fCreatedDateInLocal ??
        SqlSyntax.setField(
            _fCreatedDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  static TableField? _fProductName;
  static TableField get productName {
    return _fProductName = _fProductName ??
        SqlSyntax.setField(_fProductName, 'productName', DbType.text);
  }

  static TableField? _fProductNum;
  static TableField get productNum {
    return _fProductNum = _fProductNum ??
        SqlSyntax.setField(_fProductNum, 'productNum', DbType.integer);
  }

  static TableField? _fSerialNumber;
  static TableField get serialNumber {
    return _fSerialNumber = _fSerialNumber ??
        SqlSyntax.setField(_fSerialNumber, 'serialNumber', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fImageUrl;
  static TableField get imageUrl {
    return _fImageUrl =
        _fImageUrl ?? SqlSyntax.setField(_fImageUrl, 'imageUrl', DbType.text);
  }

  static TableField? _fCatId;
  static TableField get catId {
    return _fCatId =
        _fCatId ?? SqlSyntax.setField(_fCatId, 'catId', DbType.text);
  }

  static TableField? _fVat;
  static TableField get vat {
    return _fVat = _fVat ?? SqlSyntax.setField(_fVat, 'vat', DbType.real);
  }

  static TableField? _fCanBuy;
  static TableField get canBuy {
    return _fCanBuy =
        _fCanBuy ?? SqlSyntax.setField(_fCanBuy, 'canBuy', DbType.integer);
  }

  static TableField? _fCanSale;
  static TableField get canSale {
    return _fCanSale =
        _fCanSale ?? SqlSyntax.setField(_fCanSale, 'canSale', DbType.integer);
  }
}
// endregion ProductFields

//region ProductManager
class ProductManager extends SqfEntityProvider {
  ProductManager()
      : super(MyAppDatabaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'products';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ProductManager
// region Category
class Category extends TableBase {
  Category(
      {this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.categoryTitle,
      this.description,
      this.underMainId,
      this.isMain,
      this.isSub}) {
    _setDefaultValues();
  }
  Category.withFields(
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.categoryTitle,
      this.description,
      this.underMainId,
      this.isMain,
      this.isSub) {
    _setDefaultValues();
  }
  Category.withId(
      this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.categoryTitle,
      this.description,
      this.underMainId,
      this.isMain,
      this.isSub) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Category.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['isCanceled'] != null) {
      isCanceled = o['isCanceled'].toString() == '1' ||
          o['isCanceled'].toString() == 'true';
    }
    if (o['createdBy'] != null) {
      createdBy = o['createdBy'].toString();
    }
    if (o['createdDate'] != null) {
      createdDate = int.tryParse(o['createdDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdDate'].toString())!)
          : DateTime.tryParse(o['createdDate'].toString());
    }
    if (o['lastModifiedDate'] != null) {
      lastModifiedDate = int.tryParse(o['lastModifiedDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['lastModifiedDate'].toString())!)
          : DateTime.tryParse(o['lastModifiedDate'].toString());
    }
    if (o['modifyBy'] != null) {
      modifyBy = o['modifyBy'].toString();
    }
    if (o['createdDateInLocal'] != null) {
      createdDateInLocal =
          int.tryParse(o['createdDateInLocal'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['createdDateInLocal'].toString())!)
              : DateTime.tryParse(o['createdDateInLocal'].toString());
    }
    if (o['categoryTitle'] != null) {
      categoryTitle = o['categoryTitle'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['underMainId'] != null) {
      underMainId = int.tryParse(o['underMainId'].toString());
    }
    if (o['isMain'] != null) {
      isMain = int.tryParse(o['isMain'].toString());
    }
    if (o['isSub'] != null) {
      isSub = int.tryParse(o['isSub'].toString());
    }
  }
  // FIELDS (Category)
  int? id;
  bool? isActive;
  bool? isCanceled;
  String? createdBy;
  DateTime? createdDate;
  DateTime? lastModifiedDate;
  String? modifyBy;
  DateTime? createdDateInLocal;
  String? categoryTitle;
  String? description;
  int? underMainId;
  int? isMain;
  int? isSub;

  BoolResult? saveResult;
  // end FIELDS (Category)

  static const bool _softDeleteActivated = false;
  CategoryManager? __mnCategory;

  CategoryManager get _mnCategory {
    return __mnCategory = __mnCategory ?? CategoryManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (categoryTitle != null) {
      map['categoryTitle'] = categoryTitle;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (underMainId != null) {
      map['underMainId'] = underMainId;
    }

    if (isMain != null) {
      map['isMain'] = isMain;
    }

    if (isSub != null) {
      map['isSub'] = isSub;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (categoryTitle != null) {
      map['categoryTitle'] = categoryTitle;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (underMainId != null) {
      map['underMainId'] = underMainId;
    }

    if (isMain != null) {
      map['isMain'] = isMain;
    }

    if (isSub != null) {
      map['isSub'] = isSub;
    }

    return map;
  }

  /// This method returns Json String [Category]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Category]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      categoryTitle,
      description,
      underMainId,
      isMain,
      isSub
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      categoryTitle,
      description,
      underMainId,
      isMain,
      isSub
    ];
  }

  static Future<List<Category>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Category.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Category>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Category>[];
    try {
      objList = list
          .map((category) => Category.fromMap(category as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Category.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Category>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Category> objList = <Category>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Category.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Category by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Category if exist, otherwise returns null
  Future<Category?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Category? obj;
    final data = await _mnCategory.getById([id]);
    if (data.length != 0) {
      obj = Category.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Category) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCategory.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCategory.update(this);
    }

    return id;
  }

  /// Saves the (Category) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCategory.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCategory.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Category. Returns a new Primary Key value of Category

  /// <returns>Returns a new Primary Key value of Category
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Category> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Category> categories) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyAppDatabaseModel().batchStart();
    for (final obj in categories) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyAppDatabaseModel().batchCommit();
      for (int i = 0; i < categories.length; i++) {
        if (categories[i].id == null) {
          categories[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnCategory.rawInsert(
          'INSERT OR REPLACE INTO categories (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, categoryTitle, description, underMainId, isMain, isSub)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            isActive,
            isCanceled,
            createdBy,
            createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
            lastModifiedDate != null
                ? lastModifiedDate!.millisecondsSinceEpoch
                : null,
            modifyBy,
            createdDateInLocal != null
                ? createdDateInLocal!.millisecondsSinceEpoch
                : null,
            categoryTitle,
            description,
            underMainId,
            isMain,
            isSub
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Category id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Category id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Category Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Category>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Category> categories) async {
    final results = await _mnCategory.rawInsertAll(
        'INSERT OR REPLACE INTO categories (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, categoryTitle, description, underMainId, isMain, isSub)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
        categories);
    return results;
  }

  /// Deletes Category

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Category invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCategory
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCategory.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  CategoryFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  CategoryFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CategoryFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? false;
    isCanceled = isCanceled ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion category

// region CategoryField
class CategoryField extends SearchCriteria {
  CategoryField(this.categoryFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  CategoryFilterBuilder categoryFB;

  CategoryField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  CategoryFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    categoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categoryFB.parameters, param, SqlSyntax.EQuals,
            categoryFB._addedBlocks)
        : setCriteria(pValue, categoryFB.parameters, param, SqlSyntax.NotEQuals,
            categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    categoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.EQualsOrNull, categoryFB._addedBlocks)
        : setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder isNull() {
    categoryFB._addedBlocks = setCriteria(
        0,
        categoryFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      categoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          categoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categoryFB._addedBlocks);
      _waitingNot = '';
      categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
          categoryFB._addedBlocks.retVal;
    }
    return categoryFB;
  }

  CategoryFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      categoryFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          categoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categoryFB._addedBlocks);
      _waitingNot = '';
      categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
          categoryFB._addedBlocks.retVal;
      categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
          categoryFB._addedBlocks.retVal;
    }
    return categoryFB;
  }

  CategoryFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      categoryFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          categoryFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categoryFB._addedBlocks);
      _waitingNot = '';
      categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
          categoryFB._addedBlocks.retVal;
    }
    return categoryFB;
  }

  CategoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      categoryFB._addedBlocks = setCriteria(
          pFirst,
          categoryFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          categoryFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        categoryFB._addedBlocks = setCriteria(pFirst, categoryFB.parameters,
            param, SqlSyntax.LessThan, categoryFB._addedBlocks);
      } else {
        categoryFB._addedBlocks = setCriteria(pFirst, categoryFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, categoryFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        categoryFB._addedBlocks = setCriteria(pLast, categoryFB.parameters,
            param, SqlSyntax.GreaterThan, categoryFB._addedBlocks);
      } else {
        categoryFB._addedBlocks = setCriteria(pLast, categoryFB.parameters,
            param, SqlSyntax.LessThanOrEquals, categoryFB._addedBlocks);
      }
    }
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    categoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.GreaterThan, categoryFB._addedBlocks)
        : setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    categoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categoryFB.parameters, param, SqlSyntax.LessThan,
            categoryFB._addedBlocks)
        : setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    categoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, categoryFB._addedBlocks)
        : setCriteria(pValue, categoryFB.parameters, param, SqlSyntax.LessThan,
            categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    categoryFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.LessThanOrEquals, categoryFB._addedBlocks)
        : setCriteria(pValue, categoryFB.parameters, param,
            SqlSyntax.GreaterThan, categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }

  CategoryFilterBuilder inValues(dynamic pValue) {
    categoryFB._addedBlocks = setCriteria(
        pValue,
        categoryFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        categoryFB._addedBlocks);
    _waitingNot = '';
    categoryFB._addedBlocks.needEndBlock![categoryFB._blockIndex] =
        categoryFB._addedBlocks.retVal;
    return categoryFB;
  }
}
// endregion CategoryField

// region CategoryFilterBuilder
class CategoryFilterBuilder extends SearchCriteria {
  CategoryFilterBuilder(Category obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Category? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  CategoryFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  CategoryFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  CategoryFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  CategoryFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  CategoryFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  CategoryFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  CategoryFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CategoryFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CategoryFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CategoryFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CategoryFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  CategoryField setField(CategoryField? field, String colName, DbType dbtype) {
    return CategoryField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  CategoryField? _id;
  CategoryField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  CategoryField? _isActive;
  CategoryField get isActive {
    return _isActive = setField(_isActive, 'isActive', DbType.bool);
  }

  CategoryField? _isCanceled;
  CategoryField get isCanceled {
    return _isCanceled = setField(_isCanceled, 'isCanceled', DbType.bool);
  }

  CategoryField? _createdBy;
  CategoryField get createdBy {
    return _createdBy = setField(_createdBy, 'createdBy', DbType.text);
  }

  CategoryField? _createdDate;
  CategoryField get createdDate {
    return _createdDate =
        setField(_createdDate, 'createdDate', DbType.datetime);
  }

  CategoryField? _lastModifiedDate;
  CategoryField get lastModifiedDate {
    return _lastModifiedDate =
        setField(_lastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  CategoryField? _modifyBy;
  CategoryField get modifyBy {
    return _modifyBy = setField(_modifyBy, 'modifyBy', DbType.text);
  }

  CategoryField? _createdDateInLocal;
  CategoryField get createdDateInLocal {
    return _createdDateInLocal =
        setField(_createdDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  CategoryField? _categoryTitle;
  CategoryField get categoryTitle {
    return _categoryTitle =
        setField(_categoryTitle, 'categoryTitle', DbType.text);
  }

  CategoryField? _description;
  CategoryField get description {
    return _description = setField(_description, 'description', DbType.text);
  }

  CategoryField? _underMainId;
  CategoryField get underMainId {
    return _underMainId = setField(_underMainId, 'underMainId', DbType.integer);
  }

  CategoryField? _isMain;
  CategoryField get isMain {
    return _isMain = setField(_isMain, 'isMain', DbType.integer);
  }

  CategoryField? _isSub;
  CategoryField get isSub {
    return _isSub = setField(_isSub, 'isSub', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Category._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Category> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Category._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnCategory.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnCategory.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from categories ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnCategory.updateBatch(qparams, values);
  }

  /// This method always returns Category Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Category>
  Future<Category?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnCategory.toList(qparams);
    final data = await objFuture;
    Category? obj;
    if (data.isNotEmpty) {
      obj = Category.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Category]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? categoryCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final categoriesFuture = await _obj!._mnCategory.toList(qparams);
    final int count = categoriesFuture[0]['CNT'] as int;
    if (categoryCount != null) {
      categoryCount(count);
    }
    return count;
  }

  /// This method returns List<Category> [Category]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Category>
  Future<List<Category>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Category> categoriesData = await Category.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return categoriesData;
  }

  /// This method returns Json String [Category]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Category]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Category]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnCategory.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Category]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM categories WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnCategory.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Category]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnCategory.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Category.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnCategory.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CategoryFilterBuilder

// region CategoryFields
class CategoryFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fIsCanceled;
  static TableField get isCanceled {
    return _fIsCanceled = _fIsCanceled ??
        SqlSyntax.setField(_fIsCanceled, 'isCanceled', DbType.bool);
  }

  static TableField? _fCreatedBy;
  static TableField get createdBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'createdBy', DbType.text);
  }

  static TableField? _fCreatedDate;
  static TableField get createdDate {
    return _fCreatedDate = _fCreatedDate ??
        SqlSyntax.setField(_fCreatedDate, 'createdDate', DbType.datetime);
  }

  static TableField? _fLastModifiedDate;
  static TableField get lastModifiedDate {
    return _fLastModifiedDate = _fLastModifiedDate ??
        SqlSyntax.setField(
            _fLastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  static TableField? _fModifyBy;
  static TableField get modifyBy {
    return _fModifyBy =
        _fModifyBy ?? SqlSyntax.setField(_fModifyBy, 'modifyBy', DbType.text);
  }

  static TableField? _fCreatedDateInLocal;
  static TableField get createdDateInLocal {
    return _fCreatedDateInLocal = _fCreatedDateInLocal ??
        SqlSyntax.setField(
            _fCreatedDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  static TableField? _fCategoryTitle;
  static TableField get categoryTitle {
    return _fCategoryTitle = _fCategoryTitle ??
        SqlSyntax.setField(_fCategoryTitle, 'categoryTitle', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fUnderMainId;
  static TableField get underMainId {
    return _fUnderMainId = _fUnderMainId ??
        SqlSyntax.setField(_fUnderMainId, 'underMainId', DbType.integer);
  }

  static TableField? _fIsMain;
  static TableField get isMain {
    return _fIsMain =
        _fIsMain ?? SqlSyntax.setField(_fIsMain, 'isMain', DbType.integer);
  }

  static TableField? _fIsSub;
  static TableField get isSub {
    return _fIsSub =
        _fIsSub ?? SqlSyntax.setField(_fIsSub, 'isSub', DbType.integer);
  }
}
// endregion CategoryFields

//region CategoryManager
class CategoryManager extends SqfEntityProvider {
  CategoryManager()
      : super(MyAppDatabaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'categories';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion CategoryManager
// region UnitsProduct
class UnitsProduct extends TableBase {
  UnitsProduct(
      {this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.sellPrice,
      this.buyPrice,
      this.barcode,
      this.quantity,
      this.description,
      this.productId,
      this.unitId}) {
    _setDefaultValues();
  }
  UnitsProduct.withFields(
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.sellPrice,
      this.buyPrice,
      this.barcode,
      this.quantity,
      this.description,
      this.productId,
      this.unitId) {
    _setDefaultValues();
  }
  UnitsProduct.withId(
      this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.sellPrice,
      this.buyPrice,
      this.barcode,
      this.quantity,
      this.description,
      this.productId,
      this.unitId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  UnitsProduct.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['isCanceled'] != null) {
      isCanceled = o['isCanceled'].toString() == '1' ||
          o['isCanceled'].toString() == 'true';
    }
    if (o['createdBy'] != null) {
      createdBy = o['createdBy'].toString();
    }
    if (o['createdDate'] != null) {
      createdDate = int.tryParse(o['createdDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdDate'].toString())!)
          : DateTime.tryParse(o['createdDate'].toString());
    }
    if (o['lastModifiedDate'] != null) {
      lastModifiedDate = int.tryParse(o['lastModifiedDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['lastModifiedDate'].toString())!)
          : DateTime.tryParse(o['lastModifiedDate'].toString());
    }
    if (o['modifyBy'] != null) {
      modifyBy = o['modifyBy'].toString();
    }
    if (o['createdDateInLocal'] != null) {
      createdDateInLocal =
          int.tryParse(o['createdDateInLocal'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['createdDateInLocal'].toString())!)
              : DateTime.tryParse(o['createdDateInLocal'].toString());
    }
    if (o['sellPrice'] != null) {
      sellPrice = o['sellPrice'].toString();
    }
    if (o['buyPrice'] != null) {
      buyPrice = o['buyPrice'].toString();
    }
    if (o['barcode'] != null) {
      barcode = o['barcode'].toString();
    }
    if (o['quantity'] != null) {
      quantity = o['quantity'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['productId'] != null) {
      productId = int.tryParse(o['productId'].toString());
    }
    if (o['unitId'] != null) {
      unitId = int.tryParse(o['unitId'].toString());
    }
  }
  // FIELDS (UnitsProduct)
  int? id;
  bool? isActive;
  bool? isCanceled;
  String? createdBy;
  DateTime? createdDate;
  DateTime? lastModifiedDate;
  String? modifyBy;
  DateTime? createdDateInLocal;
  String? sellPrice;
  String? buyPrice;
  String? barcode;
  String? quantity;
  String? description;
  int? productId;
  int? unitId;

  BoolResult? saveResult;
  // end FIELDS (UnitsProduct)

  static const bool _softDeleteActivated = false;
  UnitsProductManager? __mnUnitsProduct;

  UnitsProductManager get _mnUnitsProduct {
    return __mnUnitsProduct = __mnUnitsProduct ?? UnitsProductManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (sellPrice != null) {
      map['sellPrice'] = sellPrice;
    }

    if (buyPrice != null) {
      map['buyPrice'] = buyPrice;
    }

    if (barcode != null) {
      map['barcode'] = barcode;
    }

    if (quantity != null) {
      map['quantity'] = quantity;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (productId != null) {
      map['productId'] = productId;
    }

    if (unitId != null) {
      map['unitId'] = unitId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (sellPrice != null) {
      map['sellPrice'] = sellPrice;
    }

    if (buyPrice != null) {
      map['buyPrice'] = buyPrice;
    }

    if (barcode != null) {
      map['barcode'] = barcode;
    }

    if (quantity != null) {
      map['quantity'] = quantity;
    }

    if (description != null) {
      map['description'] = description;
    }

    if (productId != null) {
      map['productId'] = productId;
    }

    if (unitId != null) {
      map['unitId'] = unitId;
    }

    return map;
  }

  /// This method returns Json String [UnitsProduct]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [UnitsProduct]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      sellPrice,
      buyPrice,
      barcode,
      quantity,
      description,
      productId,
      unitId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      sellPrice,
      buyPrice,
      barcode,
      quantity,
      description,
      productId,
      unitId
    ];
  }

  static Future<List<UnitsProduct>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR UnitsProduct.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<UnitsProduct>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <UnitsProduct>[];
    try {
      objList = list
          .map((unitsproduct) =>
              UnitsProduct.fromMap(unitsproduct as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR UnitsProduct.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<UnitsProduct>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<UnitsProduct> objList = <UnitsProduct>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = UnitsProduct.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns UnitsProduct by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns UnitsProduct if exist, otherwise returns null
  Future<UnitsProduct?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    UnitsProduct? obj;
    final data = await _mnUnitsProduct.getById([id]);
    if (data.length != 0) {
      obj = UnitsProduct.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (UnitsProduct) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUnitsProduct.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUnitsProduct.update(this);
    }

    return id;
  }

  /// Saves the (UnitsProduct) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUnitsProduct.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUnitsProduct.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs UnitsProduct. Returns a new Primary Key value of UnitsProduct

  /// <returns>Returns a new Primary Key value of UnitsProduct
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<UnitsProduct> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<UnitsProduct> unitsproducts) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyAppDatabaseModel().batchStart();
    for (final obj in unitsproducts) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyAppDatabaseModel().batchCommit();
      for (int i = 0; i < unitsproducts.length; i++) {
        if (unitsproducts[i].id == null) {
          unitsproducts[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnUnitsProduct.rawInsert(
          'INSERT OR REPLACE INTO unitsProduct (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, sellPrice, buyPrice, barcode, quantity, description, productId, unitId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            isActive,
            isCanceled,
            createdBy,
            createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
            lastModifiedDate != null
                ? lastModifiedDate!.millisecondsSinceEpoch
                : null,
            modifyBy,
            createdDateInLocal != null
                ? createdDateInLocal!.millisecondsSinceEpoch
                : null,
            sellPrice,
            buyPrice,
            barcode,
            quantity,
            description,
            productId,
            unitId
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'UnitsProduct id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'UnitsProduct id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'UnitsProduct Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<UnitsProduct>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<UnitsProduct> unitsproducts) async {
    final results = await _mnUnitsProduct.rawInsertAll(
        'INSERT OR REPLACE INTO unitsProduct (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, sellPrice, buyPrice, barcode, quantity, description, productId, unitId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        unitsproducts);
    return results;
  }

  /// Deletes UnitsProduct

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete UnitsProduct invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUnitsProduct
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUnitsProduct.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  UnitsProductFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UnitsProductFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  UnitsProductFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UnitsProductFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? false;
    isCanceled = isCanceled ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion unitsproduct

// region UnitsProductField
class UnitsProductField extends SearchCriteria {
  UnitsProductField(this.unitsproductFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  UnitsProductFilterBuilder unitsproductFB;

  UnitsProductField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  UnitsProductFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    unitsproductFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.EQuals, unitsproductFB._addedBlocks)
        : setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.NotEQuals, unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    unitsproductFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.EQualsOrNull, unitsproductFB._addedBlocks)
        : setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder isNull() {
    unitsproductFB._addedBlocks = setCriteria(
        0,
        unitsproductFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      unitsproductFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          unitsproductFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitsproductFB._addedBlocks);
      _waitingNot = '';
      unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
          unitsproductFB._addedBlocks.retVal;
    }
    return unitsproductFB;
  }

  UnitsProductFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      unitsproductFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          unitsproductFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitsproductFB._addedBlocks);
      _waitingNot = '';
      unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
          unitsproductFB._addedBlocks.retVal;
      unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
          unitsproductFB._addedBlocks.retVal;
    }
    return unitsproductFB;
  }

  UnitsProductFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      unitsproductFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          unitsproductFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitsproductFB._addedBlocks);
      _waitingNot = '';
      unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
          unitsproductFB._addedBlocks.retVal;
    }
    return unitsproductFB;
  }

  UnitsProductFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      unitsproductFB._addedBlocks = setCriteria(
          pFirst,
          unitsproductFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitsproductFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        unitsproductFB._addedBlocks = setCriteria(
            pFirst,
            unitsproductFB.parameters,
            param,
            SqlSyntax.LessThan,
            unitsproductFB._addedBlocks);
      } else {
        unitsproductFB._addedBlocks = setCriteria(
            pFirst,
            unitsproductFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            unitsproductFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        unitsproductFB._addedBlocks = setCriteria(
            pLast,
            unitsproductFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            unitsproductFB._addedBlocks);
      } else {
        unitsproductFB._addedBlocks = setCriteria(
            pLast,
            unitsproductFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            unitsproductFB._addedBlocks);
      }
    }
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    unitsproductFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.GreaterThan, unitsproductFB._addedBlocks)
        : setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.LessThanOrEquals, unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    unitsproductFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.LessThan, unitsproductFB._addedBlocks)
        : setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    unitsproductFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, unitsproductFB._addedBlocks)
        : setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.LessThan, unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    unitsproductFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.LessThanOrEquals, unitsproductFB._addedBlocks)
        : setCriteria(pValue, unitsproductFB.parameters, param,
            SqlSyntax.GreaterThan, unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }

  UnitsProductFilterBuilder inValues(dynamic pValue) {
    unitsproductFB._addedBlocks = setCriteria(
        pValue,
        unitsproductFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        unitsproductFB._addedBlocks);
    _waitingNot = '';
    unitsproductFB._addedBlocks.needEndBlock![unitsproductFB._blockIndex] =
        unitsproductFB._addedBlocks.retVal;
    return unitsproductFB;
  }
}
// endregion UnitsProductField

// region UnitsProductFilterBuilder
class UnitsProductFilterBuilder extends SearchCriteria {
  UnitsProductFilterBuilder(UnitsProduct obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  UnitsProduct? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  UnitsProductFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  UnitsProductFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  UnitsProductFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  UnitsProductFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  UnitsProductFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  UnitsProductFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  UnitsProductFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UnitsProductFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UnitsProductFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UnitsProductFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UnitsProductFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  UnitsProductField setField(
      UnitsProductField? field, String colName, DbType dbtype) {
    return UnitsProductField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  UnitsProductField? _id;
  UnitsProductField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  UnitsProductField? _isActive;
  UnitsProductField get isActive {
    return _isActive = setField(_isActive, 'isActive', DbType.bool);
  }

  UnitsProductField? _isCanceled;
  UnitsProductField get isCanceled {
    return _isCanceled = setField(_isCanceled, 'isCanceled', DbType.bool);
  }

  UnitsProductField? _createdBy;
  UnitsProductField get createdBy {
    return _createdBy = setField(_createdBy, 'createdBy', DbType.text);
  }

  UnitsProductField? _createdDate;
  UnitsProductField get createdDate {
    return _createdDate =
        setField(_createdDate, 'createdDate', DbType.datetime);
  }

  UnitsProductField? _lastModifiedDate;
  UnitsProductField get lastModifiedDate {
    return _lastModifiedDate =
        setField(_lastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  UnitsProductField? _modifyBy;
  UnitsProductField get modifyBy {
    return _modifyBy = setField(_modifyBy, 'modifyBy', DbType.text);
  }

  UnitsProductField? _createdDateInLocal;
  UnitsProductField get createdDateInLocal {
    return _createdDateInLocal =
        setField(_createdDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  UnitsProductField? _sellPrice;
  UnitsProductField get sellPrice {
    return _sellPrice = setField(_sellPrice, 'sellPrice', DbType.text);
  }

  UnitsProductField? _buyPrice;
  UnitsProductField get buyPrice {
    return _buyPrice = setField(_buyPrice, 'buyPrice', DbType.text);
  }

  UnitsProductField? _barcode;
  UnitsProductField get barcode {
    return _barcode = setField(_barcode, 'barcode', DbType.text);
  }

  UnitsProductField? _quantity;
  UnitsProductField get quantity {
    return _quantity = setField(_quantity, 'quantity', DbType.text);
  }

  UnitsProductField? _description;
  UnitsProductField get description {
    return _description = setField(_description, 'description', DbType.text);
  }

  UnitsProductField? _productId;
  UnitsProductField get productId {
    return _productId = setField(_productId, 'productId', DbType.integer);
  }

  UnitsProductField? _unitId;
  UnitsProductField get unitId {
    return _unitId = setField(_unitId, 'unitId', DbType.integer);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (UnitsProduct._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<UnitsProduct> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (UnitsProduct._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnUnitsProduct.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnUnitsProduct.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from unitsProduct ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnUnitsProduct.updateBatch(qparams, values);
  }

  /// This method always returns UnitsProduct Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<UnitsProduct>
  Future<UnitsProduct?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnUnitsProduct.toList(qparams);
    final data = await objFuture;
    UnitsProduct? obj;
    if (data.isNotEmpty) {
      obj = UnitsProduct.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [UnitsProduct]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? unitsproductCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final unitsproductsFuture = await _obj!._mnUnitsProduct.toList(qparams);
    final int count = unitsproductsFuture[0]['CNT'] as int;
    if (unitsproductCount != null) {
      unitsproductCount(count);
    }
    return count;
  }

  /// This method returns List<UnitsProduct> [UnitsProduct]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<UnitsProduct>
  Future<List<UnitsProduct>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<UnitsProduct> unitsproductsData = await UnitsProduct.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return unitsproductsData;
  }

  /// This method returns Json String [UnitsProduct]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [UnitsProduct]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [UnitsProduct]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnUnitsProduct.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [UnitsProduct]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM unitsProduct WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnUnitsProduct.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [UnitsProduct]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnUnitsProduct.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await UnitsProduct.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnUnitsProduct.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UnitsProductFilterBuilder

// region UnitsProductFields
class UnitsProductFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fIsCanceled;
  static TableField get isCanceled {
    return _fIsCanceled = _fIsCanceled ??
        SqlSyntax.setField(_fIsCanceled, 'isCanceled', DbType.bool);
  }

  static TableField? _fCreatedBy;
  static TableField get createdBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'createdBy', DbType.text);
  }

  static TableField? _fCreatedDate;
  static TableField get createdDate {
    return _fCreatedDate = _fCreatedDate ??
        SqlSyntax.setField(_fCreatedDate, 'createdDate', DbType.datetime);
  }

  static TableField? _fLastModifiedDate;
  static TableField get lastModifiedDate {
    return _fLastModifiedDate = _fLastModifiedDate ??
        SqlSyntax.setField(
            _fLastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  static TableField? _fModifyBy;
  static TableField get modifyBy {
    return _fModifyBy =
        _fModifyBy ?? SqlSyntax.setField(_fModifyBy, 'modifyBy', DbType.text);
  }

  static TableField? _fCreatedDateInLocal;
  static TableField get createdDateInLocal {
    return _fCreatedDateInLocal = _fCreatedDateInLocal ??
        SqlSyntax.setField(
            _fCreatedDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  static TableField? _fSellPrice;
  static TableField get sellPrice {
    return _fSellPrice = _fSellPrice ??
        SqlSyntax.setField(_fSellPrice, 'sellPrice', DbType.text);
  }

  static TableField? _fBuyPrice;
  static TableField get buyPrice {
    return _fBuyPrice =
        _fBuyPrice ?? SqlSyntax.setField(_fBuyPrice, 'buyPrice', DbType.text);
  }

  static TableField? _fBarcode;
  static TableField get barcode {
    return _fBarcode =
        _fBarcode ?? SqlSyntax.setField(_fBarcode, 'barcode', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'quantity', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fProductId;
  static TableField get productId {
    return _fProductId = _fProductId ??
        SqlSyntax.setField(_fProductId, 'productId', DbType.integer);
  }

  static TableField? _fUnitId;
  static TableField get unitId {
    return _fUnitId =
        _fUnitId ?? SqlSyntax.setField(_fUnitId, 'unitId', DbType.integer);
  }
}
// endregion UnitsProductFields

//region UnitsProductManager
class UnitsProductManager extends SqfEntityProvider {
  UnitsProductManager()
      : super(MyAppDatabaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'unitsProduct';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion UnitsProductManager
// region Unit
class Unit extends TableBase {
  Unit(
      {this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.unitTitle,
      this.size,
      this.needBalance}) {
    _setDefaultValues();
  }
  Unit.withFields(
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.unitTitle,
      this.size,
      this.needBalance) {
    _setDefaultValues();
  }
  Unit.withId(
      this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.unitTitle,
      this.size,
      this.needBalance) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Unit.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['isCanceled'] != null) {
      isCanceled = o['isCanceled'].toString() == '1' ||
          o['isCanceled'].toString() == 'true';
    }
    if (o['createdBy'] != null) {
      createdBy = o['createdBy'].toString();
    }
    if (o['createdDate'] != null) {
      createdDate = int.tryParse(o['createdDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdDate'].toString())!)
          : DateTime.tryParse(o['createdDate'].toString());
    }
    if (o['lastModifiedDate'] != null) {
      lastModifiedDate = int.tryParse(o['lastModifiedDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['lastModifiedDate'].toString())!)
          : DateTime.tryParse(o['lastModifiedDate'].toString());
    }
    if (o['modifyBy'] != null) {
      modifyBy = o['modifyBy'].toString();
    }
    if (o['createdDateInLocal'] != null) {
      createdDateInLocal =
          int.tryParse(o['createdDateInLocal'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['createdDateInLocal'].toString())!)
              : DateTime.tryParse(o['createdDateInLocal'].toString());
    }
    if (o['unitTitle'] != null) {
      unitTitle = o['unitTitle'].toString();
    }
    if (o['size'] != null) {
      size = o['size'].toString();
    }
    if (o['needBalance'] != null) {
      needBalance = o['needBalance'].toString();
    }
  }
  // FIELDS (Unit)
  int? id;
  bool? isActive;
  bool? isCanceled;
  String? createdBy;
  DateTime? createdDate;
  DateTime? lastModifiedDate;
  String? modifyBy;
  DateTime? createdDateInLocal;
  String? unitTitle;
  String? size;
  String? needBalance;

  BoolResult? saveResult;
  // end FIELDS (Unit)

  static const bool _softDeleteActivated = false;
  UnitManager? __mnUnit;

  UnitManager get _mnUnit {
    return __mnUnit = __mnUnit ?? UnitManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (unitTitle != null) {
      map['unitTitle'] = unitTitle;
    }

    if (size != null) {
      map['size'] = size;
    }

    if (needBalance != null) {
      map['needBalance'] = needBalance;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (unitTitle != null) {
      map['unitTitle'] = unitTitle;
    }

    if (size != null) {
      map['size'] = size;
    }

    if (needBalance != null) {
      map['needBalance'] = needBalance;
    }

    return map;
  }

  /// This method returns Json String [Unit]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Unit]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      unitTitle,
      size,
      needBalance
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      unitTitle,
      size,
      needBalance
    ];
  }

  static Future<List<Unit>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Unit.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Unit>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Unit>[];
    try {
      objList = list
          .map((unit) => Unit.fromMap(unit as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Unit.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Unit>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Unit> objList = <Unit>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Unit.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Unit by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Unit if exist, otherwise returns null
  Future<Unit?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Unit? obj;
    final data = await _mnUnit.getById([id]);
    if (data.length != 0) {
      obj = Unit.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Unit) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUnit.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUnit.update(this);
    }

    return id;
  }

  /// Saves the (Unit) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnUnit.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUnit.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Unit. Returns a new Primary Key value of Unit

  /// <returns>Returns a new Primary Key value of Unit
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Unit> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Unit> units) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyAppDatabaseModel().batchStart();
    for (final obj in units) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyAppDatabaseModel().batchCommit();
      for (int i = 0; i < units.length; i++) {
        if (units[i].id == null) {
          units[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnUnit.rawInsert(
          'INSERT OR REPLACE INTO units (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, unitTitle, size, needBalance)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            isActive,
            isCanceled,
            createdBy,
            createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
            lastModifiedDate != null
                ? lastModifiedDate!.millisecondsSinceEpoch
                : null,
            modifyBy,
            createdDateInLocal != null
                ? createdDateInLocal!.millisecondsSinceEpoch
                : null,
            unitTitle,
            size,
            needBalance
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Unit id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Unit id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Unit Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Unit>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Unit> units) async {
    final results = await _mnUnit.rawInsertAll(
        'INSERT OR REPLACE INTO units (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, unitTitle, size, needBalance)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        units);
    return results;
  }

  /// Deletes Unit

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Unit invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUnit
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnUnit.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  UnitFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UnitFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  UnitFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UnitFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? false;
    isCanceled = isCanceled ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion unit

// region UnitField
class UnitField extends SearchCriteria {
  UnitField(this.unitFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  UnitFilterBuilder unitFB;

  UnitField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  UnitFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    unitFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitFB.parameters, param, SqlSyntax.EQuals,
            unitFB._addedBlocks)
        : setCriteria(pValue, unitFB.parameters, param, SqlSyntax.NotEQuals,
            unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    unitFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitFB.parameters, param, SqlSyntax.EQualsOrNull,
            unitFB._addedBlocks)
        : setCriteria(pValue, unitFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder isNull() {
    unitFB._addedBlocks = setCriteria(
        0,
        unitFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      unitFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          unitFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitFB._addedBlocks);
      _waitingNot = '';
      unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
          unitFB._addedBlocks.retVal;
    }
    return unitFB;
  }

  UnitFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      unitFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          unitFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitFB._addedBlocks);
      _waitingNot = '';
      unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
          unitFB._addedBlocks.retVal;
      unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
          unitFB._addedBlocks.retVal;
    }
    return unitFB;
  }

  UnitFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      unitFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          unitFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitFB._addedBlocks);
      _waitingNot = '';
      unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
          unitFB._addedBlocks.retVal;
    }
    return unitFB;
  }

  UnitFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      unitFB._addedBlocks = setCriteria(
          pFirst,
          unitFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          unitFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        unitFB._addedBlocks = setCriteria(pFirst, unitFB.parameters, param,
            SqlSyntax.LessThan, unitFB._addedBlocks);
      } else {
        unitFB._addedBlocks = setCriteria(pFirst, unitFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, unitFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        unitFB._addedBlocks = setCriteria(pLast, unitFB.parameters, param,
            SqlSyntax.GreaterThan, unitFB._addedBlocks);
      } else {
        unitFB._addedBlocks = setCriteria(pLast, unitFB.parameters, param,
            SqlSyntax.LessThanOrEquals, unitFB._addedBlocks);
      }
    }
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    unitFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitFB.parameters, param, SqlSyntax.GreaterThan,
            unitFB._addedBlocks)
        : setCriteria(pValue, unitFB.parameters, param,
            SqlSyntax.LessThanOrEquals, unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    unitFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitFB.parameters, param, SqlSyntax.LessThan,
            unitFB._addedBlocks)
        : setCriteria(pValue, unitFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    unitFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, unitFB._addedBlocks)
        : setCriteria(pValue, unitFB.parameters, param, SqlSyntax.LessThan,
            unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    unitFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, unitFB.parameters, param,
            SqlSyntax.LessThanOrEquals, unitFB._addedBlocks)
        : setCriteria(pValue, unitFB.parameters, param, SqlSyntax.GreaterThan,
            unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }

  UnitFilterBuilder inValues(dynamic pValue) {
    unitFB._addedBlocks = setCriteria(
        pValue,
        unitFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        unitFB._addedBlocks);
    _waitingNot = '';
    unitFB._addedBlocks.needEndBlock![unitFB._blockIndex] =
        unitFB._addedBlocks.retVal;
    return unitFB;
  }
}
// endregion UnitField

// region UnitFilterBuilder
class UnitFilterBuilder extends SearchCriteria {
  UnitFilterBuilder(Unit obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Unit? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  UnitFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  UnitFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  UnitFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  UnitFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  UnitFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  UnitFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  UnitFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UnitFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UnitFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UnitFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UnitFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  UnitField setField(UnitField? field, String colName, DbType dbtype) {
    return UnitField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  UnitField? _id;
  UnitField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  UnitField? _isActive;
  UnitField get isActive {
    return _isActive = setField(_isActive, 'isActive', DbType.bool);
  }

  UnitField? _isCanceled;
  UnitField get isCanceled {
    return _isCanceled = setField(_isCanceled, 'isCanceled', DbType.bool);
  }

  UnitField? _createdBy;
  UnitField get createdBy {
    return _createdBy = setField(_createdBy, 'createdBy', DbType.text);
  }

  UnitField? _createdDate;
  UnitField get createdDate {
    return _createdDate =
        setField(_createdDate, 'createdDate', DbType.datetime);
  }

  UnitField? _lastModifiedDate;
  UnitField get lastModifiedDate {
    return _lastModifiedDate =
        setField(_lastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  UnitField? _modifyBy;
  UnitField get modifyBy {
    return _modifyBy = setField(_modifyBy, 'modifyBy', DbType.text);
  }

  UnitField? _createdDateInLocal;
  UnitField get createdDateInLocal {
    return _createdDateInLocal =
        setField(_createdDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  UnitField? _unitTitle;
  UnitField get unitTitle {
    return _unitTitle = setField(_unitTitle, 'unitTitle', DbType.text);
  }

  UnitField? _size;
  UnitField get size {
    return _size = setField(_size, 'size', DbType.text);
  }

  UnitField? _needBalance;
  UnitField get needBalance {
    return _needBalance = setField(_needBalance, 'needBalance', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Unit._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Unit> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Unit._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnUnit.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnUnit.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from units ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnUnit.updateBatch(qparams, values);
  }

  /// This method always returns Unit Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Unit>
  Future<Unit?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnUnit.toList(qparams);
    final data = await objFuture;
    Unit? obj;
    if (data.isNotEmpty) {
      obj = Unit.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Unit]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? unitCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final unitsFuture = await _obj!._mnUnit.toList(qparams);
    final int count = unitsFuture[0]['CNT'] as int;
    if (unitCount != null) {
      unitCount(count);
    }
    return count;
  }

  /// This method returns List<Unit> [Unit]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Unit>
  Future<List<Unit>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Unit> unitsData = await Unit.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return unitsData;
  }

  /// This method returns Json String [Unit]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Unit]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Unit]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnUnit.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Unit]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM units WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnUnit.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Unit]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnUnit.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Unit.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnUnit.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UnitFilterBuilder

// region UnitFields
class UnitFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fIsCanceled;
  static TableField get isCanceled {
    return _fIsCanceled = _fIsCanceled ??
        SqlSyntax.setField(_fIsCanceled, 'isCanceled', DbType.bool);
  }

  static TableField? _fCreatedBy;
  static TableField get createdBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'createdBy', DbType.text);
  }

  static TableField? _fCreatedDate;
  static TableField get createdDate {
    return _fCreatedDate = _fCreatedDate ??
        SqlSyntax.setField(_fCreatedDate, 'createdDate', DbType.datetime);
  }

  static TableField? _fLastModifiedDate;
  static TableField get lastModifiedDate {
    return _fLastModifiedDate = _fLastModifiedDate ??
        SqlSyntax.setField(
            _fLastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  static TableField? _fModifyBy;
  static TableField get modifyBy {
    return _fModifyBy =
        _fModifyBy ?? SqlSyntax.setField(_fModifyBy, 'modifyBy', DbType.text);
  }

  static TableField? _fCreatedDateInLocal;
  static TableField get createdDateInLocal {
    return _fCreatedDateInLocal = _fCreatedDateInLocal ??
        SqlSyntax.setField(
            _fCreatedDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  static TableField? _fUnitTitle;
  static TableField get unitTitle {
    return _fUnitTitle = _fUnitTitle ??
        SqlSyntax.setField(_fUnitTitle, 'unitTitle', DbType.text);
  }

  static TableField? _fSize;
  static TableField get size {
    return _fSize = _fSize ?? SqlSyntax.setField(_fSize, 'size', DbType.text);
  }

  static TableField? _fNeedBalance;
  static TableField get needBalance {
    return _fNeedBalance = _fNeedBalance ??
        SqlSyntax.setField(_fNeedBalance, 'needBalance', DbType.text);
  }
}
// endregion UnitFields

//region UnitManager
class UnitManager extends SqfEntityProvider {
  UnitManager()
      : super(MyAppDatabaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'units';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion UnitManager
// region BuyInvoice
class BuyInvoice extends TableBase {
  BuyInvoice(
      {this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.discountType,
      this.vatPercent,
      this.countItem,
      this.clientId,
      this.clientName,
      this.totalNetBill,
      this.totalBeforeDiscount,
      this.discountAmount,
      this.totalAfterDiscount,
      this.vatAmount,
      this.totalAfterVAT,
      this.totalBillFinal,
      this.payedAmount,
      this.remainingAmount,
      this.notPayedAmount}) {
    _setDefaultValues();
  }
  BuyInvoice.withFields(
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.discountType,
      this.vatPercent,
      this.countItem,
      this.clientId,
      this.clientName,
      this.totalNetBill,
      this.totalBeforeDiscount,
      this.discountAmount,
      this.totalAfterDiscount,
      this.vatAmount,
      this.totalAfterVAT,
      this.totalBillFinal,
      this.payedAmount,
      this.remainingAmount,
      this.notPayedAmount) {
    _setDefaultValues();
  }
  BuyInvoice.withId(
      this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.discountType,
      this.vatPercent,
      this.countItem,
      this.clientId,
      this.clientName,
      this.totalNetBill,
      this.totalBeforeDiscount,
      this.discountAmount,
      this.totalAfterDiscount,
      this.vatAmount,
      this.totalAfterVAT,
      this.totalBillFinal,
      this.payedAmount,
      this.remainingAmount,
      this.notPayedAmount) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BuyInvoice.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['isCanceled'] != null) {
      isCanceled = o['isCanceled'].toString() == '1' ||
          o['isCanceled'].toString() == 'true';
    }
    if (o['createdBy'] != null) {
      createdBy = o['createdBy'].toString();
    }
    if (o['createdDate'] != null) {
      createdDate = int.tryParse(o['createdDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdDate'].toString())!)
          : DateTime.tryParse(o['createdDate'].toString());
    }
    if (o['lastModifiedDate'] != null) {
      lastModifiedDate = int.tryParse(o['lastModifiedDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['lastModifiedDate'].toString())!)
          : DateTime.tryParse(o['lastModifiedDate'].toString());
    }
    if (o['modifyBy'] != null) {
      modifyBy = o['modifyBy'].toString();
    }
    if (o['createdDateInLocal'] != null) {
      createdDateInLocal =
          int.tryParse(o['createdDateInLocal'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['createdDateInLocal'].toString())!)
              : DateTime.tryParse(o['createdDateInLocal'].toString());
    }
    if (o['discountType'] != null) {
      discountType = int.tryParse(o['discountType'].toString());
    }
    if (o['vatPercent'] != null) {
      vatPercent = int.tryParse(o['vatPercent'].toString());
    }
    if (o['countItem'] != null) {
      countItem = int.tryParse(o['countItem'].toString());
    }
    if (o['clientId'] != null) {
      clientId = o['clientId'].toString();
    }
    if (o['clientName'] != null) {
      clientName = o['clientName'].toString();
    }
    if (o['totalNetBill'] != null) {
      totalNetBill = o['totalNetBill'].toString();
    }
    if (o['totalBeforeDiscount'] != null) {
      totalBeforeDiscount = o['totalBeforeDiscount'].toString();
    }
    if (o['discountAmount'] != null) {
      discountAmount = o['discountAmount'].toString();
    }
    if (o['totalAfterDiscount'] != null) {
      totalAfterDiscount = o['totalAfterDiscount'].toString();
    }
    if (o['vatAmount'] != null) {
      vatAmount = o['vatAmount'].toString();
    }
    if (o['totalAfterVAT'] != null) {
      totalAfterVAT = o['totalAfterVAT'].toString();
    }
    if (o['totalBillFinal'] != null) {
      totalBillFinal = o['totalBillFinal'].toString();
    }
    if (o['payedAmount'] != null) {
      payedAmount = o['payedAmount'].toString();
    }
    if (o['remainingAmount'] != null) {
      remainingAmount = o['remainingAmount'].toString();
    }
    if (o['notPayedAmount'] != null) {
      notPayedAmount = o['notPayedAmount'].toString();
    }
  }
  // FIELDS (BuyInvoice)
  int? id;
  bool? isActive;
  bool? isCanceled;
  String? createdBy;
  DateTime? createdDate;
  DateTime? lastModifiedDate;
  String? modifyBy;
  DateTime? createdDateInLocal;
  int? discountType;
  int? vatPercent;
  int? countItem;
  String? clientId;
  String? clientName;
  String? totalNetBill;
  String? totalBeforeDiscount;
  String? discountAmount;
  String? totalAfterDiscount;
  String? vatAmount;
  String? totalAfterVAT;
  String? totalBillFinal;
  String? payedAmount;
  String? remainingAmount;
  String? notPayedAmount;

  BoolResult? saveResult;
  // end FIELDS (BuyInvoice)

  static const bool _softDeleteActivated = false;
  BuyInvoiceManager? __mnBuyInvoice;

  BuyInvoiceManager get _mnBuyInvoice {
    return __mnBuyInvoice = __mnBuyInvoice ?? BuyInvoiceManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (discountType != null) {
      map['discountType'] = discountType;
    }

    if (vatPercent != null) {
      map['vatPercent'] = vatPercent;
    }

    if (countItem != null) {
      map['countItem'] = countItem;
    }

    if (clientId != null) {
      map['clientId'] = clientId;
    }

    if (clientName != null) {
      map['clientName'] = clientName;
    }

    if (totalNetBill != null) {
      map['totalNetBill'] = totalNetBill;
    }

    if (totalBeforeDiscount != null) {
      map['totalBeforeDiscount'] = totalBeforeDiscount;
    }

    if (discountAmount != null) {
      map['discountAmount'] = discountAmount;
    }

    if (totalAfterDiscount != null) {
      map['totalAfterDiscount'] = totalAfterDiscount;
    }

    if (vatAmount != null) {
      map['vatAmount'] = vatAmount;
    }

    if (totalAfterVAT != null) {
      map['totalAfterVAT'] = totalAfterVAT;
    }

    if (totalBillFinal != null) {
      map['totalBillFinal'] = totalBillFinal;
    }

    if (payedAmount != null) {
      map['payedAmount'] = payedAmount;
    }

    if (remainingAmount != null) {
      map['remainingAmount'] = remainingAmount;
    }

    if (notPayedAmount != null) {
      map['notPayedAmount'] = notPayedAmount;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (discountType != null) {
      map['discountType'] = discountType;
    }

    if (vatPercent != null) {
      map['vatPercent'] = vatPercent;
    }

    if (countItem != null) {
      map['countItem'] = countItem;
    }

    if (clientId != null) {
      map['clientId'] = clientId;
    }

    if (clientName != null) {
      map['clientName'] = clientName;
    }

    if (totalNetBill != null) {
      map['totalNetBill'] = totalNetBill;
    }

    if (totalBeforeDiscount != null) {
      map['totalBeforeDiscount'] = totalBeforeDiscount;
    }

    if (discountAmount != null) {
      map['discountAmount'] = discountAmount;
    }

    if (totalAfterDiscount != null) {
      map['totalAfterDiscount'] = totalAfterDiscount;
    }

    if (vatAmount != null) {
      map['vatAmount'] = vatAmount;
    }

    if (totalAfterVAT != null) {
      map['totalAfterVAT'] = totalAfterVAT;
    }

    if (totalBillFinal != null) {
      map['totalBillFinal'] = totalBillFinal;
    }

    if (payedAmount != null) {
      map['payedAmount'] = payedAmount;
    }

    if (remainingAmount != null) {
      map['remainingAmount'] = remainingAmount;
    }

    if (notPayedAmount != null) {
      map['notPayedAmount'] = notPayedAmount;
    }

    return map;
  }

  /// This method returns Json String [BuyInvoice]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BuyInvoice]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      discountType,
      vatPercent,
      countItem,
      clientId,
      clientName,
      totalNetBill,
      totalBeforeDiscount,
      discountAmount,
      totalAfterDiscount,
      vatAmount,
      totalAfterVAT,
      totalBillFinal,
      payedAmount,
      remainingAmount,
      notPayedAmount
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      discountType,
      vatPercent,
      countItem,
      clientId,
      clientName,
      totalNetBill,
      totalBeforeDiscount,
      discountAmount,
      totalAfterDiscount,
      vatAmount,
      totalAfterVAT,
      totalBillFinal,
      payedAmount,
      remainingAmount,
      notPayedAmount
    ];
  }

  static Future<List<BuyInvoice>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BuyInvoice.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BuyInvoice>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BuyInvoice>[];
    try {
      objList = list
          .map((buyinvoice) =>
              BuyInvoice.fromMap(buyinvoice as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BuyInvoice.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BuyInvoice>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BuyInvoice> objList = <BuyInvoice>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BuyInvoice.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BuyInvoice by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns BuyInvoice if exist, otherwise returns null
  Future<BuyInvoice?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    BuyInvoice? obj;
    final data = await _mnBuyInvoice.getById([id]);
    if (data.length != 0) {
      obj = BuyInvoice.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BuyInvoice) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnBuyInvoice.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBuyInvoice.update(this);
    }

    return id;
  }

  /// Saves the (BuyInvoice) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnBuyInvoice.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBuyInvoice.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs BuyInvoice. Returns a new Primary Key value of BuyInvoice

  /// <returns>Returns a new Primary Key value of BuyInvoice
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<BuyInvoice> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BuyInvoice> buyinvoices) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyAppDatabaseModel().batchStart();
    for (final obj in buyinvoices) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyAppDatabaseModel().batchCommit();
      for (int i = 0; i < buyinvoices.length; i++) {
        if (buyinvoices[i].id == null) {
          buyinvoices[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnBuyInvoice.rawInsert(
          'INSERT OR REPLACE INTO buyInvoices (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, discountType, vatPercent, countItem, clientId, clientName, totalNetBill, totalBeforeDiscount, discountAmount, totalAfterDiscount, vatAmount, totalAfterVAT, totalBillFinal, payedAmount, remainingAmount, notPayedAmount)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            isActive,
            isCanceled,
            createdBy,
            createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
            lastModifiedDate != null
                ? lastModifiedDate!.millisecondsSinceEpoch
                : null,
            modifyBy,
            createdDateInLocal != null
                ? createdDateInLocal!.millisecondsSinceEpoch
                : null,
            discountType,
            vatPercent,
            countItem,
            clientId,
            clientName,
            totalNetBill,
            totalBeforeDiscount,
            discountAmount,
            totalAfterDiscount,
            vatAmount,
            totalAfterVAT,
            totalBillFinal,
            payedAmount,
            remainingAmount,
            notPayedAmount
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BuyInvoice id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'BuyInvoice id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BuyInvoice Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BuyInvoice>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<BuyInvoice> buyinvoices) async {
    final results = await _mnBuyInvoice.rawInsertAll(
        'INSERT OR REPLACE INTO buyInvoices (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, discountType, vatPercent, countItem, clientId, clientName, totalNetBill, totalBeforeDiscount, discountAmount, totalAfterDiscount, vatAmount, totalAfterVAT, totalBillFinal, payedAmount, remainingAmount, notPayedAmount)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        buyinvoices);
    return results;
  }

  /// Deletes BuyInvoice

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BuyInvoice invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBuyInvoice
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnBuyInvoice.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  BuyInvoiceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BuyInvoiceFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  BuyInvoiceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BuyInvoiceFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? false;
    isCanceled = isCanceled ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion buyinvoice

// region BuyInvoiceField
class BuyInvoiceField extends SearchCriteria {
  BuyInvoiceField(this.buyinvoiceFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  BuyInvoiceFilterBuilder buyinvoiceFB;

  BuyInvoiceField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  BuyInvoiceFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    buyinvoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, buyinvoiceFB.parameters, param, SqlSyntax.EQuals,
            buyinvoiceFB._addedBlocks)
        : setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.NotEQuals, buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    buyinvoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.EQualsOrNull, buyinvoiceFB._addedBlocks)
        : setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder isNull() {
    buyinvoiceFB._addedBlocks = setCriteria(
        0,
        buyinvoiceFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      buyinvoiceFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          buyinvoiceFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          buyinvoiceFB._addedBlocks);
      _waitingNot = '';
      buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
          buyinvoiceFB._addedBlocks.retVal;
    }
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      buyinvoiceFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          buyinvoiceFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          buyinvoiceFB._addedBlocks);
      _waitingNot = '';
      buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
          buyinvoiceFB._addedBlocks.retVal;
      buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
          buyinvoiceFB._addedBlocks.retVal;
    }
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      buyinvoiceFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          buyinvoiceFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          buyinvoiceFB._addedBlocks);
      _waitingNot = '';
      buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
          buyinvoiceFB._addedBlocks.retVal;
    }
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      buyinvoiceFB._addedBlocks = setCriteria(
          pFirst,
          buyinvoiceFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          buyinvoiceFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        buyinvoiceFB._addedBlocks = setCriteria(pFirst, buyinvoiceFB.parameters,
            param, SqlSyntax.LessThan, buyinvoiceFB._addedBlocks);
      } else {
        buyinvoiceFB._addedBlocks = setCriteria(pFirst, buyinvoiceFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, buyinvoiceFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        buyinvoiceFB._addedBlocks = setCriteria(pLast, buyinvoiceFB.parameters,
            param, SqlSyntax.GreaterThan, buyinvoiceFB._addedBlocks);
      } else {
        buyinvoiceFB._addedBlocks = setCriteria(pLast, buyinvoiceFB.parameters,
            param, SqlSyntax.LessThanOrEquals, buyinvoiceFB._addedBlocks);
      }
    }
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    buyinvoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.GreaterThan, buyinvoiceFB._addedBlocks)
        : setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.LessThanOrEquals, buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    buyinvoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.LessThan, buyinvoiceFB._addedBlocks)
        : setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    buyinvoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, buyinvoiceFB._addedBlocks)
        : setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.LessThan, buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    buyinvoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.LessThanOrEquals, buyinvoiceFB._addedBlocks)
        : setCriteria(pValue, buyinvoiceFB.parameters, param,
            SqlSyntax.GreaterThan, buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }

  BuyInvoiceFilterBuilder inValues(dynamic pValue) {
    buyinvoiceFB._addedBlocks = setCriteria(
        pValue,
        buyinvoiceFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        buyinvoiceFB._addedBlocks);
    _waitingNot = '';
    buyinvoiceFB._addedBlocks.needEndBlock![buyinvoiceFB._blockIndex] =
        buyinvoiceFB._addedBlocks.retVal;
    return buyinvoiceFB;
  }
}
// endregion BuyInvoiceField

// region BuyInvoiceFilterBuilder
class BuyInvoiceFilterBuilder extends SearchCriteria {
  BuyInvoiceFilterBuilder(BuyInvoice obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  BuyInvoice? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  BuyInvoiceFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  BuyInvoiceFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  BuyInvoiceFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  BuyInvoiceFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  BuyInvoiceFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  BuyInvoiceFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  BuyInvoiceFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  BuyInvoiceFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  BuyInvoiceFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  BuyInvoiceFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  BuyInvoiceFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  BuyInvoiceField setField(
      BuyInvoiceField? field, String colName, DbType dbtype) {
    return BuyInvoiceField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  BuyInvoiceField? _id;
  BuyInvoiceField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  BuyInvoiceField? _isActive;
  BuyInvoiceField get isActive {
    return _isActive = setField(_isActive, 'isActive', DbType.bool);
  }

  BuyInvoiceField? _isCanceled;
  BuyInvoiceField get isCanceled {
    return _isCanceled = setField(_isCanceled, 'isCanceled', DbType.bool);
  }

  BuyInvoiceField? _createdBy;
  BuyInvoiceField get createdBy {
    return _createdBy = setField(_createdBy, 'createdBy', DbType.text);
  }

  BuyInvoiceField? _createdDate;
  BuyInvoiceField get createdDate {
    return _createdDate =
        setField(_createdDate, 'createdDate', DbType.datetime);
  }

  BuyInvoiceField? _lastModifiedDate;
  BuyInvoiceField get lastModifiedDate {
    return _lastModifiedDate =
        setField(_lastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  BuyInvoiceField? _modifyBy;
  BuyInvoiceField get modifyBy {
    return _modifyBy = setField(_modifyBy, 'modifyBy', DbType.text);
  }

  BuyInvoiceField? _createdDateInLocal;
  BuyInvoiceField get createdDateInLocal {
    return _createdDateInLocal =
        setField(_createdDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  BuyInvoiceField? _discountType;
  BuyInvoiceField get discountType {
    return _discountType =
        setField(_discountType, 'discountType', DbType.integer);
  }

  BuyInvoiceField? _vatPercent;
  BuyInvoiceField get vatPercent {
    return _vatPercent = setField(_vatPercent, 'vatPercent', DbType.integer);
  }

  BuyInvoiceField? _countItem;
  BuyInvoiceField get countItem {
    return _countItem = setField(_countItem, 'countItem', DbType.integer);
  }

  BuyInvoiceField? _clientId;
  BuyInvoiceField get clientId {
    return _clientId = setField(_clientId, 'clientId', DbType.text);
  }

  BuyInvoiceField? _clientName;
  BuyInvoiceField get clientName {
    return _clientName = setField(_clientName, 'clientName', DbType.text);
  }

  BuyInvoiceField? _totalNetBill;
  BuyInvoiceField get totalNetBill {
    return _totalNetBill = setField(_totalNetBill, 'totalNetBill', DbType.text);
  }

  BuyInvoiceField? _totalBeforeDiscount;
  BuyInvoiceField get totalBeforeDiscount {
    return _totalBeforeDiscount =
        setField(_totalBeforeDiscount, 'totalBeforeDiscount', DbType.text);
  }

  BuyInvoiceField? _discountAmount;
  BuyInvoiceField get discountAmount {
    return _discountAmount =
        setField(_discountAmount, 'discountAmount', DbType.text);
  }

  BuyInvoiceField? _totalAfterDiscount;
  BuyInvoiceField get totalAfterDiscount {
    return _totalAfterDiscount =
        setField(_totalAfterDiscount, 'totalAfterDiscount', DbType.text);
  }

  BuyInvoiceField? _vatAmount;
  BuyInvoiceField get vatAmount {
    return _vatAmount = setField(_vatAmount, 'vatAmount', DbType.text);
  }

  BuyInvoiceField? _totalAfterVAT;
  BuyInvoiceField get totalAfterVAT {
    return _totalAfterVAT =
        setField(_totalAfterVAT, 'totalAfterVAT', DbType.text);
  }

  BuyInvoiceField? _totalBillFinal;
  BuyInvoiceField get totalBillFinal {
    return _totalBillFinal =
        setField(_totalBillFinal, 'totalBillFinal', DbType.text);
  }

  BuyInvoiceField? _payedAmount;
  BuyInvoiceField get payedAmount {
    return _payedAmount = setField(_payedAmount, 'payedAmount', DbType.text);
  }

  BuyInvoiceField? _remainingAmount;
  BuyInvoiceField get remainingAmount {
    return _remainingAmount =
        setField(_remainingAmount, 'remainingAmount', DbType.text);
  }

  BuyInvoiceField? _notPayedAmount;
  BuyInvoiceField get notPayedAmount {
    return _notPayedAmount =
        setField(_notPayedAmount, 'notPayedAmount', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (BuyInvoice._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<BuyInvoice> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (BuyInvoice._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnBuyInvoice.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnBuyInvoice.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from buyInvoices ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnBuyInvoice.updateBatch(qparams, values);
  }

  /// This method always returns BuyInvoice Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<BuyInvoice>
  Future<BuyInvoice?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnBuyInvoice.toList(qparams);
    final data = await objFuture;
    BuyInvoice? obj;
    if (data.isNotEmpty) {
      obj = BuyInvoice.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [BuyInvoice]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? buyinvoiceCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final buyinvoicesFuture = await _obj!._mnBuyInvoice.toList(qparams);
    final int count = buyinvoicesFuture[0]['CNT'] as int;
    if (buyinvoiceCount != null) {
      buyinvoiceCount(count);
    }
    return count;
  }

  /// This method returns List<BuyInvoice> [BuyInvoice]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<BuyInvoice>
  Future<List<BuyInvoice>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BuyInvoice> buyinvoicesData = await BuyInvoice.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return buyinvoicesData;
  }

  /// This method returns Json String [BuyInvoice]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BuyInvoice]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BuyInvoice]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnBuyInvoice.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BuyInvoice]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM buyInvoices WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnBuyInvoice.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BuyInvoice]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnBuyInvoice.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await BuyInvoice.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnBuyInvoice.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BuyInvoiceFilterBuilder

// region BuyInvoiceFields
class BuyInvoiceFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fIsCanceled;
  static TableField get isCanceled {
    return _fIsCanceled = _fIsCanceled ??
        SqlSyntax.setField(_fIsCanceled, 'isCanceled', DbType.bool);
  }

  static TableField? _fCreatedBy;
  static TableField get createdBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'createdBy', DbType.text);
  }

  static TableField? _fCreatedDate;
  static TableField get createdDate {
    return _fCreatedDate = _fCreatedDate ??
        SqlSyntax.setField(_fCreatedDate, 'createdDate', DbType.datetime);
  }

  static TableField? _fLastModifiedDate;
  static TableField get lastModifiedDate {
    return _fLastModifiedDate = _fLastModifiedDate ??
        SqlSyntax.setField(
            _fLastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  static TableField? _fModifyBy;
  static TableField get modifyBy {
    return _fModifyBy =
        _fModifyBy ?? SqlSyntax.setField(_fModifyBy, 'modifyBy', DbType.text);
  }

  static TableField? _fCreatedDateInLocal;
  static TableField get createdDateInLocal {
    return _fCreatedDateInLocal = _fCreatedDateInLocal ??
        SqlSyntax.setField(
            _fCreatedDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  static TableField? _fDiscountType;
  static TableField get discountType {
    return _fDiscountType = _fDiscountType ??
        SqlSyntax.setField(_fDiscountType, 'discountType', DbType.integer);
  }

  static TableField? _fVatPercent;
  static TableField get vatPercent {
    return _fVatPercent = _fVatPercent ??
        SqlSyntax.setField(_fVatPercent, 'vatPercent', DbType.integer);
  }

  static TableField? _fCountItem;
  static TableField get countItem {
    return _fCountItem = _fCountItem ??
        SqlSyntax.setField(_fCountItem, 'countItem', DbType.integer);
  }

  static TableField? _fClientId;
  static TableField get clientId {
    return _fClientId =
        _fClientId ?? SqlSyntax.setField(_fClientId, 'clientId', DbType.text);
  }

  static TableField? _fClientName;
  static TableField get clientName {
    return _fClientName = _fClientName ??
        SqlSyntax.setField(_fClientName, 'clientName', DbType.text);
  }

  static TableField? _fTotalNetBill;
  static TableField get totalNetBill {
    return _fTotalNetBill = _fTotalNetBill ??
        SqlSyntax.setField(_fTotalNetBill, 'totalNetBill', DbType.text);
  }

  static TableField? _fTotalBeforeDiscount;
  static TableField get totalBeforeDiscount {
    return _fTotalBeforeDiscount = _fTotalBeforeDiscount ??
        SqlSyntax.setField(
            _fTotalBeforeDiscount, 'totalBeforeDiscount', DbType.text);
  }

  static TableField? _fDiscountAmount;
  static TableField get discountAmount {
    return _fDiscountAmount = _fDiscountAmount ??
        SqlSyntax.setField(_fDiscountAmount, 'discountAmount', DbType.text);
  }

  static TableField? _fTotalAfterDiscount;
  static TableField get totalAfterDiscount {
    return _fTotalAfterDiscount = _fTotalAfterDiscount ??
        SqlSyntax.setField(
            _fTotalAfterDiscount, 'totalAfterDiscount', DbType.text);
  }

  static TableField? _fVatAmount;
  static TableField get vatAmount {
    return _fVatAmount = _fVatAmount ??
        SqlSyntax.setField(_fVatAmount, 'vatAmount', DbType.text);
  }

  static TableField? _fTotalAfterVAT;
  static TableField get totalAfterVAT {
    return _fTotalAfterVAT = _fTotalAfterVAT ??
        SqlSyntax.setField(_fTotalAfterVAT, 'totalAfterVAT', DbType.text);
  }

  static TableField? _fTotalBillFinal;
  static TableField get totalBillFinal {
    return _fTotalBillFinal = _fTotalBillFinal ??
        SqlSyntax.setField(_fTotalBillFinal, 'totalBillFinal', DbType.text);
  }

  static TableField? _fPayedAmount;
  static TableField get payedAmount {
    return _fPayedAmount = _fPayedAmount ??
        SqlSyntax.setField(_fPayedAmount, 'payedAmount', DbType.text);
  }

  static TableField? _fRemainingAmount;
  static TableField get remainingAmount {
    return _fRemainingAmount = _fRemainingAmount ??
        SqlSyntax.setField(_fRemainingAmount, 'remainingAmount', DbType.text);
  }

  static TableField? _fNotPayedAmount;
  static TableField get notPayedAmount {
    return _fNotPayedAmount = _fNotPayedAmount ??
        SqlSyntax.setField(_fNotPayedAmount, 'notPayedAmount', DbType.text);
  }
}
// endregion BuyInvoiceFields

//region BuyInvoiceManager
class BuyInvoiceManager extends SqfEntityProvider {
  BuyInvoiceManager()
      : super(MyAppDatabaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'buyInvoices';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion BuyInvoiceManager
// region InvoiceDetail
class InvoiceDetail extends TableBase {
  InvoiceDetail(
      {this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.invoiceId,
      this.unitProductId,
      this.quantity}) {
    _setDefaultValues();
  }
  InvoiceDetail.withFields(
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.invoiceId,
      this.unitProductId,
      this.quantity) {
    _setDefaultValues();
  }
  InvoiceDetail.withId(
      this.id,
      this.isActive,
      this.isCanceled,
      this.createdBy,
      this.createdDate,
      this.lastModifiedDate,
      this.modifyBy,
      this.createdDateInLocal,
      this.invoiceId,
      this.unitProductId,
      this.quantity) {
    _setDefaultValues();
  }
  // fromMap v2.0
  InvoiceDetail.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['isCanceled'] != null) {
      isCanceled = o['isCanceled'].toString() == '1' ||
          o['isCanceled'].toString() == 'true';
    }
    if (o['createdBy'] != null) {
      createdBy = o['createdBy'].toString();
    }
    if (o['createdDate'] != null) {
      createdDate = int.tryParse(o['createdDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['createdDate'].toString())!)
          : DateTime.tryParse(o['createdDate'].toString());
    }
    if (o['lastModifiedDate'] != null) {
      lastModifiedDate = int.tryParse(o['lastModifiedDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['lastModifiedDate'].toString())!)
          : DateTime.tryParse(o['lastModifiedDate'].toString());
    }
    if (o['modifyBy'] != null) {
      modifyBy = o['modifyBy'].toString();
    }
    if (o['createdDateInLocal'] != null) {
      createdDateInLocal =
          int.tryParse(o['createdDateInLocal'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['createdDateInLocal'].toString())!)
              : DateTime.tryParse(o['createdDateInLocal'].toString());
    }
    if (o['invoiceId'] != null) {
      invoiceId = o['invoiceId'].toString();
    }
    if (o['unitProductId'] != null) {
      unitProductId = o['unitProductId'].toString();
    }
    if (o['quantity'] != null) {
      quantity = o['quantity'].toString();
    }
  }
  // FIELDS (InvoiceDetail)
  int? id;
  bool? isActive;
  bool? isCanceled;
  String? createdBy;
  DateTime? createdDate;
  DateTime? lastModifiedDate;
  String? modifyBy;
  DateTime? createdDateInLocal;
  String? invoiceId;
  String? unitProductId;
  String? quantity;

  BoolResult? saveResult;
  // end FIELDS (InvoiceDetail)

  static const bool _softDeleteActivated = false;
  InvoiceDetailManager? __mnInvoiceDetail;

  InvoiceDetailManager get _mnInvoiceDetail {
    return __mnInvoiceDetail = __mnInvoiceDetail ?? InvoiceDetailManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (invoiceId != null) {
      map['invoiceId'] = invoiceId;
    }

    if (unitProductId != null) {
      map['unitProductId'] = unitProductId;
    }

    if (quantity != null) {
      map['quantity'] = quantity;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    }

    if (isCanceled != null) {
      map['isCanceled'] = forQuery ? (isCanceled! ? 1 : 0) : isCanceled;
    }

    if (createdBy != null) {
      map['createdBy'] = createdBy;
    }

    if (createdDate != null) {
      map['createdDate'] = forJson
          ? createdDate!.toString()
          : forQuery
              ? createdDate!.millisecondsSinceEpoch
              : createdDate;
    }

    if (lastModifiedDate != null) {
      map['lastModifiedDate'] = forJson
          ? lastModifiedDate!.toString()
          : forQuery
              ? lastModifiedDate!.millisecondsSinceEpoch
              : lastModifiedDate;
    }

    if (modifyBy != null) {
      map['modifyBy'] = modifyBy;
    }

    if (createdDateInLocal != null) {
      map['createdDateInLocal'] = forJson
          ? createdDateInLocal!.toString()
          : forQuery
              ? createdDateInLocal!.millisecondsSinceEpoch
              : createdDateInLocal;
    }

    if (invoiceId != null) {
      map['invoiceId'] = invoiceId;
    }

    if (unitProductId != null) {
      map['unitProductId'] = unitProductId;
    }

    if (quantity != null) {
      map['quantity'] = quantity;
    }

    return map;
  }

  /// This method returns Json String [InvoiceDetail]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [InvoiceDetail]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      invoiceId,
      unitProductId,
      quantity
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      isActive,
      isCanceled,
      createdBy,
      createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
      lastModifiedDate != null
          ? lastModifiedDate!.millisecondsSinceEpoch
          : null,
      modifyBy,
      createdDateInLocal != null
          ? createdDateInLocal!.millisecondsSinceEpoch
          : null,
      invoiceId,
      unitProductId,
      quantity
    ];
  }

  static Future<List<InvoiceDetail>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InvoiceDetail.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<InvoiceDetail>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <InvoiceDetail>[];
    try {
      objList = list
          .map((invoicedetail) =>
              InvoiceDetail.fromMap(invoicedetail as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InvoiceDetail.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<InvoiceDetail>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<InvoiceDetail> objList = <InvoiceDetail>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = InvoiceDetail.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns InvoiceDetail by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns InvoiceDetail if exist, otherwise returns null
  Future<InvoiceDetail?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    InvoiceDetail? obj;
    final data = await _mnInvoiceDetail.getById([id]);
    if (data.length != 0) {
      obj = InvoiceDetail.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (InvoiceDetail) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnInvoiceDetail.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInvoiceDetail.update(this);
    }

    return id;
  }

  /// Saves the (InvoiceDetail) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnInvoiceDetail.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInvoiceDetail.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs InvoiceDetail. Returns a new Primary Key value of InvoiceDetail

  /// <returns>Returns a new Primary Key value of InvoiceDetail
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<InvoiceDetail> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<InvoiceDetail> invoicedetails) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyAppDatabaseModel().batchStart();
    for (final obj in invoicedetails) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyAppDatabaseModel().batchCommit();
      for (int i = 0; i < invoicedetails.length; i++) {
        if (invoicedetails[i].id == null) {
          invoicedetails[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert() async {
    try {
      final result = await _mnInvoiceDetail.rawInsert(
          'INSERT OR REPLACE INTO invoiceDetails (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, invoiceId, unitProductId, quantity)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            isActive,
            isCanceled,
            createdBy,
            createdDate != null ? createdDate!.millisecondsSinceEpoch : null,
            lastModifiedDate != null
                ? lastModifiedDate!.millisecondsSinceEpoch
                : null,
            modifyBy,
            createdDateInLocal != null
                ? createdDateInLocal!.millisecondsSinceEpoch
                : null,
            invoiceId,
            unitProductId,
            quantity
          ]);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'InvoiceDetail id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'InvoiceDetail id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'InvoiceDetail Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<InvoiceDetail>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<InvoiceDetail> invoicedetails) async {
    final results = await _mnInvoiceDetail.rawInsertAll(
        'INSERT OR REPLACE INTO invoiceDetails (id, isActive, isCanceled, createdBy, createdDate, lastModifiedDate, modifyBy, createdDateInLocal, invoiceId, unitProductId, quantity)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        invoicedetails);
    return results;
  }

  /// Deletes InvoiceDetail

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete InvoiceDetail invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInvoiceDetail
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnInvoiceDetail.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  InvoiceDetailFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceDetailFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  InvoiceDetailFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceDetailFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? false;
    isCanceled = isCanceled ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion invoicedetail

// region InvoiceDetailField
class InvoiceDetailField extends SearchCriteria {
  InvoiceDetailField(this.invoicedetailFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  InvoiceDetailFilterBuilder invoicedetailFB;

  InvoiceDetailField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  InvoiceDetailFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    invoicedetailFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.EQuals, invoicedetailFB._addedBlocks)
        : setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.NotEQuals, invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    invoicedetailFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.EQualsOrNull, invoicedetailFB._addedBlocks)
        : setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder isNull() {
    invoicedetailFB._addedBlocks = setCriteria(
        0,
        invoicedetailFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      invoicedetailFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          invoicedetailFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicedetailFB._addedBlocks);
      _waitingNot = '';
      invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
          invoicedetailFB._addedBlocks.retVal;
    }
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      invoicedetailFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          invoicedetailFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicedetailFB._addedBlocks);
      _waitingNot = '';
      invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
          invoicedetailFB._addedBlocks.retVal;
      invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
          invoicedetailFB._addedBlocks.retVal;
    }
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      invoicedetailFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          invoicedetailFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicedetailFB._addedBlocks);
      _waitingNot = '';
      invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
          invoicedetailFB._addedBlocks.retVal;
    }
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      invoicedetailFB._addedBlocks = setCriteria(
          pFirst,
          invoicedetailFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicedetailFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        invoicedetailFB._addedBlocks = setCriteria(
            pFirst,
            invoicedetailFB.parameters,
            param,
            SqlSyntax.LessThan,
            invoicedetailFB._addedBlocks);
      } else {
        invoicedetailFB._addedBlocks = setCriteria(
            pFirst,
            invoicedetailFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            invoicedetailFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        invoicedetailFB._addedBlocks = setCriteria(
            pLast,
            invoicedetailFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            invoicedetailFB._addedBlocks);
      } else {
        invoicedetailFB._addedBlocks = setCriteria(
            pLast,
            invoicedetailFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            invoicedetailFB._addedBlocks);
      }
    }
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    invoicedetailFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.GreaterThan, invoicedetailFB._addedBlocks)
        : setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.LessThanOrEquals, invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    invoicedetailFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.LessThan, invoicedetailFB._addedBlocks)
        : setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    invoicedetailFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, invoicedetailFB._addedBlocks)
        : setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.LessThan, invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    invoicedetailFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.LessThanOrEquals, invoicedetailFB._addedBlocks)
        : setCriteria(pValue, invoicedetailFB.parameters, param,
            SqlSyntax.GreaterThan, invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }

  InvoiceDetailFilterBuilder inValues(dynamic pValue) {
    invoicedetailFB._addedBlocks = setCriteria(
        pValue,
        invoicedetailFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        invoicedetailFB._addedBlocks);
    _waitingNot = '';
    invoicedetailFB._addedBlocks.needEndBlock![invoicedetailFB._blockIndex] =
        invoicedetailFB._addedBlocks.retVal;
    return invoicedetailFB;
  }
}
// endregion InvoiceDetailField

// region InvoiceDetailFilterBuilder
class InvoiceDetailFilterBuilder extends SearchCriteria {
  InvoiceDetailFilterBuilder(InvoiceDetail obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  InvoiceDetail? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  InvoiceDetailFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  InvoiceDetailFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  InvoiceDetailFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  InvoiceDetailFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  InvoiceDetailFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  InvoiceDetailFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  InvoiceDetailFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  InvoiceDetailFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  InvoiceDetailFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  InvoiceDetailFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  InvoiceDetailFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  InvoiceDetailField setField(
      InvoiceDetailField? field, String colName, DbType dbtype) {
    return InvoiceDetailField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  InvoiceDetailField? _id;
  InvoiceDetailField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  InvoiceDetailField? _isActive;
  InvoiceDetailField get isActive {
    return _isActive = setField(_isActive, 'isActive', DbType.bool);
  }

  InvoiceDetailField? _isCanceled;
  InvoiceDetailField get isCanceled {
    return _isCanceled = setField(_isCanceled, 'isCanceled', DbType.bool);
  }

  InvoiceDetailField? _createdBy;
  InvoiceDetailField get createdBy {
    return _createdBy = setField(_createdBy, 'createdBy', DbType.text);
  }

  InvoiceDetailField? _createdDate;
  InvoiceDetailField get createdDate {
    return _createdDate =
        setField(_createdDate, 'createdDate', DbType.datetime);
  }

  InvoiceDetailField? _lastModifiedDate;
  InvoiceDetailField get lastModifiedDate {
    return _lastModifiedDate =
        setField(_lastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  InvoiceDetailField? _modifyBy;
  InvoiceDetailField get modifyBy {
    return _modifyBy = setField(_modifyBy, 'modifyBy', DbType.text);
  }

  InvoiceDetailField? _createdDateInLocal;
  InvoiceDetailField get createdDateInLocal {
    return _createdDateInLocal =
        setField(_createdDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  InvoiceDetailField? _invoiceId;
  InvoiceDetailField get invoiceId {
    return _invoiceId = setField(_invoiceId, 'invoiceId', DbType.text);
  }

  InvoiceDetailField? _unitProductId;
  InvoiceDetailField get unitProductId {
    return _unitProductId =
        setField(_unitProductId, 'unitProductId', DbType.text);
  }

  InvoiceDetailField? _quantity;
  InvoiceDetailField get quantity {
    return _quantity = setField(_quantity, 'quantity', DbType.text);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (InvoiceDetail._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<InvoiceDetail> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (InvoiceDetail._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnInvoiceDetail.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnInvoiceDetail.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from invoiceDetails ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnInvoiceDetail.updateBatch(qparams, values);
  }

  /// This method always returns InvoiceDetail Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<InvoiceDetail>
  Future<InvoiceDetail?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnInvoiceDetail.toList(qparams);
    final data = await objFuture;
    InvoiceDetail? obj;
    if (data.isNotEmpty) {
      obj = InvoiceDetail.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [InvoiceDetail]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? invoicedetailCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final invoicedetailsFuture = await _obj!._mnInvoiceDetail.toList(qparams);
    final int count = invoicedetailsFuture[0]['CNT'] as int;
    if (invoicedetailCount != null) {
      invoicedetailCount(count);
    }
    return count;
  }

  /// This method returns List<InvoiceDetail> [InvoiceDetail]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<InvoiceDetail>
  Future<List<InvoiceDetail>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<InvoiceDetail> invoicedetailsData =
        await InvoiceDetail.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return invoicedetailsData;
  }

  /// This method returns Json String [InvoiceDetail]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [InvoiceDetail]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [InvoiceDetail]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnInvoiceDetail.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [InvoiceDetail]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM invoiceDetails WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnInvoiceDetail.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [InvoiceDetail]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnInvoiceDetail.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await InvoiceDetail.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnInvoiceDetail.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InvoiceDetailFilterBuilder

// region InvoiceDetailFields
class InvoiceDetailFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fIsCanceled;
  static TableField get isCanceled {
    return _fIsCanceled = _fIsCanceled ??
        SqlSyntax.setField(_fIsCanceled, 'isCanceled', DbType.bool);
  }

  static TableField? _fCreatedBy;
  static TableField get createdBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'createdBy', DbType.text);
  }

  static TableField? _fCreatedDate;
  static TableField get createdDate {
    return _fCreatedDate = _fCreatedDate ??
        SqlSyntax.setField(_fCreatedDate, 'createdDate', DbType.datetime);
  }

  static TableField? _fLastModifiedDate;
  static TableField get lastModifiedDate {
    return _fLastModifiedDate = _fLastModifiedDate ??
        SqlSyntax.setField(
            _fLastModifiedDate, 'lastModifiedDate', DbType.datetime);
  }

  static TableField? _fModifyBy;
  static TableField get modifyBy {
    return _fModifyBy =
        _fModifyBy ?? SqlSyntax.setField(_fModifyBy, 'modifyBy', DbType.text);
  }

  static TableField? _fCreatedDateInLocal;
  static TableField get createdDateInLocal {
    return _fCreatedDateInLocal = _fCreatedDateInLocal ??
        SqlSyntax.setField(
            _fCreatedDateInLocal, 'createdDateInLocal', DbType.datetime);
  }

  static TableField? _fInvoiceId;
  static TableField get invoiceId {
    return _fInvoiceId = _fInvoiceId ??
        SqlSyntax.setField(_fInvoiceId, 'invoiceId', DbType.text);
  }

  static TableField? _fUnitProductId;
  static TableField get unitProductId {
    return _fUnitProductId = _fUnitProductId ??
        SqlSyntax.setField(_fUnitProductId, 'unitProductId', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'quantity', DbType.text);
  }
}
// endregion InvoiceDetailFields

//region InvoiceDetailManager
class InvoiceDetailManager extends SqfEntityProvider {
  InvoiceDetailManager()
      : super(MyAppDatabaseModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'invoiceDetails';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion InvoiceDetailManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await MyAppDatabaseModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await MyAppDatabaseModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await MyAppDatabaseModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class MyAppDatabaseModelSequenceManager extends SqfEntityProvider {
  MyAppDatabaseModelSequenceManager() : super(MyAppDatabaseModel());
}
// END OF ENTITIES
